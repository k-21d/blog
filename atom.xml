<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://k-21d.github.io</id>
    <title>学习博客</title>
    <updated>2020-04-05T17:45:36.950Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://k-21d.github.io"/>
    <link rel="self" href="https://k-21d.github.io/atom.xml"/>
    <subtitle>Java Blog</subtitle>
    <logo>https://k-21d.github.io/images/avatar.png</logo>
    <icon>https://k-21d.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 学习博客</rights>
    <entry>
        <title type="html"><![CDATA[Spring IoC 依赖来源]]></title>
        <id>https://k-21d.github.io/post/spring-ioc-yi-lai-lai-yuan/</id>
        <link href="https://k-21d.github.io/post/spring-ioc-yi-lai-lai-yuan/">
        </link>
        <updated>2020-02-12T12:18:17.000Z</updated>
        <content type="html"><![CDATA[<p>Spring IOC的三种依赖来源：</p>
<ul>
<li>
<p>自定义注册的Spring bean，通过xml、注解或者api注册BeanDefination创建的</p>
</li>
<li>
<p>内建的Spring bean，通过registerSingleton()创建的</p>
</li>
<li>
<p>内建的可注入的依赖，通过registerResolveDependency()创建</p>
<p>后续如果我们需要往Spring容器里放入一些非Spring托管的bean但又可以被依赖注入的, 可以通过registerResolveDependency() API实现</p>
</li>
</ul>
<h2 id="依赖查找的来源">依赖查找的来源</h2>
<h3 id="查找来源">查找来源</h3>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td><bean id="user" class="org.geekbang...User"></td>
</tr>
<tr>
<td></td>
<td>@Bean public User user(){...}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API 实现</td>
</tr>
</tbody>
</table>
<h3 id="spring-內建-beandefintion">Spring 內建 BeanDefintion</h3>
<table>
<thead>
<tr>
<th>Bean 实例</th>
<th>使用场景</th>
<th>Bean 名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConfigurationClassPostProcessor 对象</td>
<td>处理 Spring 配置类</td>
<td><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code></td>
</tr>
<tr>
<td>AutowiredAnnotationBeanPostProcessor 对象</td>
<td>处理 @Autowired 以及 @Value注解</td>
<td><code>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</code></td>
</tr>
<tr>
<td>CommonAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JSR-250 注解，如 @PostConstruct 等</td>
<td><code>org.springframework.context.annotation.internalCommonAnnotationProcessor</code></td>
</tr>
<tr>
<td>EventListenerMethodProcessor对象</td>
<td>处理标注 @EventListener 的Spring 事件监听方法</td>
<td><code>org.springframework.context.event.internalEventListenerProcessor</code></td>
</tr>
<tr>
<td>DefaultEventListenerFactory 对象</td>
<td>@EventListener 事件监听方法适配为 ApplicationListener</td>
<td><code>org.springframework.context.event.internalEventListenerFactory</code></td>
</tr>
<tr>
<td>PersistenceAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JPA 注解场景</td>
<td><code>org.springframework.context.annotation.internalPersistenceAnnotationProcessor</code></td>
</tr>
</tbody>
</table>
<h3 id="spring-內建单例对象">Spring 內建单例对象</h3>
<table>
<thead>
<tr>
<th>Bean 名称</th>
<th>Bean 实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>Environment 对象</td>
<td>外部化配置以及 Profiles</td>
</tr>
<tr>
<td>systemProperties</td>
<td>java.util.Properties 对象</td>
<td>java.util.Properties 对象</td>
</tr>
<tr>
<td>systemEnvironment</td>
<td>java.util.Map 对象</td>
<td>操作系统环境变量</td>
</tr>
<tr>
<td>messageSource</td>
<td>MessageSource 对象</td>
<td>国际化文案</td>
</tr>
<tr>
<td>lifecycleProcessor</td>
<td>LifecycleProcessor 对象</td>
<td>Lifecycle Bean 处理器</td>
</tr>
<tr>
<td>applicationEventMulticaster</td>
<td>ApplicationEventMulticaster 对象</td>
<td>Spring 事件广播器</td>
</tr>
</tbody>
</table>
<h2 id="依赖注入的来源">依赖注入的来源</h2>
<h3 id="注入来源">注入来源</h3>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td><bean id="user" class="org.geekbang...User"></td>
</tr>
<tr>
<td></td>
<td>@Bean public User user(){...}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API 实现</td>
</tr>
<tr>
<td>非Spring容器管理对象</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="spring-容器管理和游离对象">Spring 容器管理和游离对象</h2>
<p>依赖对象</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>Spring Bean 对象</th>
<th>生命周期管理</th>
<th>配置元信息</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td>是</td>
<td>是</td>
<td>有</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>单体对象</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>Resolvable Dependency</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>依赖注入</td>
</tr>
</tbody>
</table>
<h3 id="spring-beandefinition-作为依赖来源">Spring BeanDefinition 作为依赖来源</h3>
<ul>
<li>元数据：BeanDefinition</li>
<li>注册：BeanDefinitionRegistry#registerBeanDefinition</li>
<li>类型：延迟和非延迟</li>
<li>顺序：Bean 生命周期顺序按照注册顺序</li>
</ul>
<h3 id="单例对象作为依赖来源">单例对象作为依赖来源</h3>
<h4 id="要素">要素</h4>
<ul>
<li>来源：外部普通 Java 对象（不一定是 POJO）</li>
<li>注册：SingletonBeanRegistry#registerSingleton</li>
</ul>
<h4 id="限制">限制</h4>
<ul>
<li>无生命周期管理</li>
<li>无法实现延迟初始化 Bean</li>
</ul>
<h3 id="非-spring-容器管理对象作为依赖来源">非 Spring 容器管理对象作为依赖来源</h3>
<h4 id="要素-2">要素</h4>
<ul>
<li>注册：ConfigurableListableBeanFactory#registerResolvableDependency</li>
</ul>
<h4 id="限制-2">限制</h4>
<ul>
<li>无生命周期管理</li>
<li>无法实现延迟初始化 Bean</li>
<li>无法通过依赖查找</li>
</ul>
<h3 id="外部化配置作为依赖来源">外部化配置作为依赖来源</h3>
<h4 id="要素-3">要素</h4>
<ul>
<li>类型：非常规 Spring 对象依赖来源</li>
</ul>
<h4 id="限制-3">限制</h4>
<ul>
<li>无生命周期管理</li>
<li>无法实现延迟初始化 Bean</li>
<li>无法通过依赖查找</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC 注入]]></title>
        <id>https://k-21d.github.io/post/spring-ioc-zhu-ru/</id>
        <link href="https://k-21d.github.io/post/spring-ioc-zhu-ru/">
        </link>
        <updated>2020-02-06T03:39:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="依赖注入的模式和类型">依赖注入的模式和类型</h2>
<h3 id="手动模式">手动模式</h3>
<p>配置或者编程的方式，提前安排注入规则</p>
<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
<h3 id="自动模式">自动模式</h3>
<p>实现方提供依赖自动关联的方式，按照內建的注入规则</p>
<ul>
<li>Autowiring（自动绑定）</li>
</ul>
<h3 id="依赖注入类型">依赖注入类型</h3>
<table>
<thead>
<tr>
<th>依赖注入类型</th>
<th>配置元数据举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Setter 方法</td>
<td><proeprty name="user" ref="userBean" /></td>
</tr>
<tr>
<td>构造器</td>
<td><constructor-arg name="user" ref="userBean" /></td>
</tr>
<tr>
<td>字段</td>
<td>@Autowired User user;</td>
</tr>
<tr>
<td>方法</td>
<td>@Autowired public void user(User user) { ... }</td>
</tr>
<tr>
<td>接口回调</td>
<td>class MyBean implements BeanFactoryAware { ... }</td>
</tr>
</tbody>
</table>
<h2 id="自动绑定autowiring">自动绑定（Autowiring）</h2>
<h3 id="官方说明">官方说明</h3>
<blockquote>
<p>The Spring container can autowire relationships between collaborating beans. You can let Spring<br>
resolve collaborators (other beans) automatically for your bean by inspecting the contents of the<br>
ApplicationContext.</p>
</blockquote>
<h3 id="优点">优点</h3>
<ul>
<li>Autowiring can significantly reduce the need to specify properties or constructor arguments.</li>
<li>Autowiring can update a configuration as your objects evolve.</li>
</ul>
<h2 id="自动绑定autowiring模式">自动绑定（Autowiring）模式</h2>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no</td>
<td>默认值，未激活 Autowiring，需要手动指定依赖注入对象</td>
</tr>
<tr>
<td>byName</td>
<td>根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>byType</td>
<td>根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>constructor</td>
<td>constructor</td>
</tr>
</tbody>
</table>
<h2 id="自动绑定autowiring限制和不足">自动绑定（Autowiring）限制和不足</h2>
<p>Limitations and Disadvantages of Autowiring 小节</p>
<p>https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-frameworkreference/core.html#beans-autowired-exceptions</p>
<h2 id="setter-方法依赖注入">Setter 方法依赖注入</h2>
<h3 id="手动模式-2">手动模式</h3>
<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
<h3 id="自动模式-2">自动模式</h3>
<ul>
<li>byName</li>
<li>byType</li>
</ul>
<h2 id="构造器依赖注入">构造器依赖注入</h2>
<h3 id="手动模式-3">手动模式</h3>
<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
<h3 id="自动模式-3">自动模式</h3>
<ul>
<li>constructor</li>
</ul>
<h2 id="字段注入">字段注入</h2>
<h3 id="手动模式-4">手动模式</h3>
<ul>
<li>Java 注解配置元信息
<ul>
<li>@Autowired  :会忽略静态字段</li>
<li>@Resource</li>
<li>@Inject（可选）</li>
</ul>
</li>
</ul>
<h2 id="方法注入">方法注入</h2>
<h3 id="手动模式-5">手动模式</h3>
<ul>
<li>Java 注解配置元信息
<ul>
<li>@Autowired</li>
<li>@Resource</li>
<li>@Inject（可选）</li>
<li>@Bean</li>
</ul>
</li>
</ul>
<h2 id="回调注入">回调注入</h2>
<p>Aware 系列接口回调</p>
<table>
<thead>
<tr>
<th>內建接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeanFactoryAware</td>
<td>获取 IoC 容器 - BeanFactory</td>
</tr>
<tr>
<td>ApplicationContextAware</td>
<td>获取 Spring 应用上下文 - ApplicationContext 对象</td>
</tr>
<tr>
<td>EnvironmentAware</td>
<td>获取 Environment 对象</td>
</tr>
<tr>
<td>ResourceLoaderAware</td>
<td>获取资源加载器 对象 - ResourceLoader</td>
</tr>
<tr>
<td>BeanClassLoaderAware</td>
<td>获取加载当前 Bean Class 的 ClassLoader</td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>获取当前 Bean 的名称</td>
</tr>
<tr>
<td>MessageSourceAware</td>
<td>获取 MessageSource 对象，用于 Spring 国际化</td>
</tr>
<tr>
<td>ApplicationEventPublisherAware</td>
<td>获取 ApplicationEventPublishAware 对象，用于 Spring 事件</td>
</tr>
<tr>
<td>EmbeddedValueResolverAware</td>
<td>获取 StringValueResolver 对象，用于占位符处理</td>
</tr>
</tbody>
</table>
<h2 id="依赖注入类型选择">依赖注入类型选择</h2>
<ul>
<li>低依赖：构造器注入</li>
<li>多依赖：Setter方法注入</li>
<li>便利性：字段注入</li>
<li>声明类：方法注入</li>
</ul>
<h3 id="基础类型注入">基础类型注入</h3>
<ul>
<li>原生类型（Primitive）：boolean、byte、char、short、int、float、long、double</li>
<li>标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li>
<li>常规类型（General）：Object、String、TimeZone、Calendar、Optional</li>
<li>Spring类型：Resource、InputSource、Formatter等</li>
</ul>
<h3 id="集合类型注入">集合类型注入</h3>
<ul>
<li>数组类型（Array）：原生类型、标量类型、常规类型、Spring类型</li>
<li>集合类型（Collection）
<ul>
<li>Collection：List、Set（SortedSet、Navigable、EnumSet）</li>
<li>Map：Properties</li>
</ul>
</li>
</ul>
<h3 id="限定注入">限定注入</h3>
<ul>
<li>使用注解@Qualifier限定
<ul>
<li>通过Bean名称限定</li>
<li>通过分组限定</li>
</ul>
</li>
<li>基于注解@Qualifier拓展限定
<ul>
<li>自定义注解-如Spring  Cloud @LoadBalanced</li>
</ul>
</li>
</ul>
<h3 id="延迟依赖注入">延迟依赖注入</h3>
<ul>
<li>使用API ObjectFactory延迟注入
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
<li>使用API ObjectProvider延迟注入（推荐）
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
</ul>
<h2 id="依赖处理过程">依赖处理过程</h2>
<h3 id="基础知识">基础知识</h3>
<ul>
<li>
<p>入口：<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code></p>
<pre><code>	@Override
	@Nullable
	public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
			@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
		if (Optional.class == descriptor.getDependencyType()) {
			return createOptionalDependency(descriptor, requestingBeanName);
		}
		else if (ObjectFactory.class == descriptor.getDependencyType() ||
				ObjectProvider.class == descriptor.getDependencyType()) {
			return new DependencyObjectProvider(descriptor, requestingBeanName);
		}
		else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
			return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
		}
		else {
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
					descriptor, requestingBeanName);
			if (result == null) {
				result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
			}
			return result;
		}
	}
</code></pre>
</li>
<li>
<p>依赖描述符：<code>org.springframework.beans.factory.config.DependencyDescriptor</code></p>
</li>
<li>
<p>自定绑定候选对象处理器：<code>org.springframework.beans.factory.support.AutowireCandidateResolver</code></p>
</li>
</ul>
<h3 id="autowired-注入原理">@Autowired 注入原理</h3>
<ul>
<li>元信息解析</li>
<li>依赖查找</li>
<li>依赖注入（字段、方法）</li>
</ul>
<p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p>
<pre><code>		@Override
		protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
			Field field = (Field) this.member;
			Object value;
			if (this.cached) {
				value = resolvedCachedArgument(beanName, this.cachedFieldValue);
			}
			else {
				DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
				desc.setContainingClass(bean.getClass());
				Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(1);
				Assert.state(beanFactory != null, &quot;No BeanFactory available&quot;);
				TypeConverter typeConverter = beanFactory.getTypeConverter();
				try {
					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
				}
				catch (BeansException ex) {
					throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
				}
				synchronized (this) {
					if (!this.cached) {
						if (value != null || this.required) {
							this.cachedFieldValue = desc;
							registerDependentBeans(beanName, autowiredBeanNames);
							if (autowiredBeanNames.size() == 1) {
								String autowiredBeanName = autowiredBeanNames.iterator().next();
								if (beanFactory.containsBean(autowiredBeanName) &amp;&amp;
										beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
									this.cachedFieldValue = new ShortcutDependencyDescriptor(
											desc, autowiredBeanName, field.getType());
								}
							}
						}
						else {
							this.cachedFieldValue = null;
						}
						this.cached = true;
					}
				}
			}
			if (value != null) {
				ReflectionUtils.makeAccessible(field);
				field.set(bean, value);
			}
		}
	}
</code></pre>
<h3 id="jsr-330-inject-注入原理">JSR-330 @Inject 注入原理</h3>
<pre><code>javax.inject.Inject
</code></pre>
<h3 id="java通用注解注入原理">Java通用注解注入原理</h3>
<p>CommonAnnotationBeanPostProcessor</p>
<ul>
<li>注入注解
<ul>
<li><code>java.x.xml.ws.WebServiceRef</code></li>
<li><code>javax.ejb.EJB</code></li>
<li><code>javax.annotation.Resource</code></li>
</ul>
</li>
<li>生命周期注解
<ul>
<li><code>javax.annotation.PostConstruct</code></li>
<li><code>javax.annotation.PreDestroy</code></li>
</ul>
</li>
</ul>
<h3 id="自定义依赖注入注解">自定义依赖注入注解</h3>
<ul>
<li>
<p>基于AutowiredAnnotationBeanPostProcessor实现</p>
<pre><code>@Bean
public static AutowiredAnnotationBeanPostProcessor beanPostProcessor(){
	AutowiredAnnotationBeanPostProcessor beanPostProcessor = new AutowiredAnnotationBeanPostProcessor();
	//替换原有的注解处理
	beanPostProcessor.setAutowiredAnnotationType(自定义注解.class);
	return beanPostProcessor;
}
</code></pre>
</li>
<li>
<p>自定义实现</p>
<ul>
<li>生命周期处理
<ul>
<li>InstantiationAwareBeanPostProcessor</li>
<li>MergedBeanDefinitionPostProcessor</li>
</ul>
</li>
<li>元数据
<ul>
<li>InjectedElement</li>
<li>InjectionMetadata</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC依赖查找]]></title>
        <id>https://k-21d.github.io/post/spring-yi-lai-cha-zhao/</id>
        <link href="https://k-21d.github.io/post/spring-yi-lai-cha-zhao/">
        </link>
        <updated>2020-02-01T13:47:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="单一类型依赖查找">单一类型依赖查找</h2>
<p>单一类型依赖查找接口 - BeanFactory</p>
<h3 id="根据-bean-名称查找">根据 Bean 名称查找</h3>
<ul>
<li>getBean(String)</li>
<li>Spring 2.5 覆盖默认参数：getBean(String,Object...)</li>
</ul>
<h3 id="根据-bean-类型查找">根据 Bean 类型查找</h3>
<ul>
<li>
<p>Bean 实时查找</p>
<ul>
<li>Spring 3.0 getBean(Class)</li>
<li>Spring 4.1 覆盖默认参数：getBean(Class,Object...)</li>
</ul>
</li>
<li>
<p>Spring 5.1 Bean 延迟查找</p>
<ul>
<li>
<p>getBeanProvider(Class)</p>
<pre><code>public class ObjectProviderDemo {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        applicationContext.register(ObjectProviderDemo.class);
        applicationContext.refresh();
        lookupByObjectProvider(applicationContext);
        applicationContext.close();
    }

    @Bean
    public String helloWorld(){
        //方法名就是Bean的名称
        return &quot;Hello,World&quot;;
    }
    private static void lookupByObjectProvider(AnnotationConfigApplicationContext applicationContext) {
        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);
        System.out.println(beanProvider.getObject());
    }
}
</code></pre>
</li>
<li>
<p>getBeanProvider(ResolvableType)</p>
</li>
</ul>
</li>
</ul>
<h3 id="根据-bean-名称-类型查找getbeanstringclass">根据 Bean 名称 + 类型查找：getBean(String,Class)</h3>
<h2 id="集合类型依赖查找">集合类型依赖查找</h2>
<p>集合类型依赖查找接口 - ListableBeanFactory</p>
<h3 id="根据-bean-类型查找-2">根据 Bean 类型查找</h3>
<ul>
<li>获取同类型 Bean 名称列表
<ul>
<li>getBeanNamesForType(Class)</li>
<li>Spring 4.2 getBeanNamesForType(ResolvableType)</li>
</ul>
</li>
<li>获取同类型 Bean 实例列表
<ul>
<li>getBeansOfType(Class) 以及重载方法</li>
</ul>
</li>
</ul>
<h3 id="通过注解类型查找">通过注解类型查找</h3>
<ul>
<li>Spring 3.0 获取标注类型 Bean 名称列表
<ul>
<li>getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt;)</li>
</ul>
</li>
<li>Spring 3.0 获取标注类型 Bean 实例列表
<ul>
<li>getBeansWithAnnotation(Class&lt;? extends Annotation&gt;)</li>
</ul>
</li>
<li>Spring 3.0 获取指定名称 + 标注类型 Bean 实例
<ul>
<li>findAnnotationOnBean(String,Class&lt;? extends Annotation&gt;)</li>
</ul>
</li>
</ul>
<h2 id="层次性依赖查找">层次性依赖查找</h2>
<p>层次性依赖查找接口 - HierarchicalBeanFactory</p>
<h3 id="双亲-beanfactorygetparentbeanfactory">双亲 BeanFactory：getParentBeanFactory()</h3>
<h3 id="层次性查找">层次性查找</h3>
<ul>
<li>根据 Bean 名称查找
<ul>
<li>基于 containsLocalBean 方法实现</li>
</ul>
</li>
<li>根据 Bean 类型查找实例列表
<ul>
<li>单一类型：BeanFactoryUtils#beanOfType</li>
<li>集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors</li>
</ul>
</li>
<li>根据 Java 注解查找名称列表
<ul>
<li>集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors</li>
</ul>
</li>
</ul>
<h2 id="延迟依赖查找">延迟依赖查找</h2>
<ul>
<li>
<p><code>org.springframework.beans.factory.ObjectFactory</code></p>
</li>
<li>
<p><code>org.springframework.beans.factory.ObjectProvider</code></p>
<ul>
<li>
<p>Spring 5 对 Java 8 特性扩展</p>
<ul>
<li>
<p>函数式接口</p>
<ul>
<li>
<p>getIfAvailable(Supplier)</p>
<pre><code>ObjectProvider&lt;User&gt; beanProvider = applicationContext.getBeanProvider(User.class);
User user = beanProvider.getIfAvailable(User::createUser);
</code></pre>
</li>
<li>
<p>ifAvailable(Consumer)</p>
</li>
</ul>
</li>
<li>
<p>Stream 扩展 - stream()</p>
<pre><code>@Bean
public String message(){
   return &quot;Message&quot;;
}
private static void looupByStreamOps(AnnotationConfigApplicationContext applicationContext) {
        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);
        beanProvider.stream().forEach(System.out::print);
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全依赖查找">安全依赖查找</h2>
<p>依赖查找安全性对比</p>
<table>
<thead>
<tr>
<th>依赖查找类型</th>
<th style="text-align:left">代表实现</th>
<th style="text-align:center">是否安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一类型查找</td>
<td style="text-align:left">BeanFactory#getBean</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">ObjectFactory#getObject</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">ObjectProvider#getIfAvailable</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>集合类型查找</td>
<td style="text-align:left">ListableBeanFactory#getBeansOfType</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">ObjectProvider#stream</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 BeanFactory 接口</p>
<h2 id="内建可查找的依赖">内建可查找的依赖</h2>
<p>AbstractApplicationContext 内建可查找的依赖</p>
<table>
<thead>
<tr>
<th>Bean 名称</th>
<th>Bean 实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>Environment 对象</td>
<td>外部化配置以及 Profiles</td>
</tr>
<tr>
<td>systemProperties</td>
<td>java.util.Properties 对象</td>
<td>java.util.Properties 对象</td>
</tr>
<tr>
<td>systemEnvironment</td>
<td>java.util.Map 对象</td>
<td>操作系统环境变量</td>
</tr>
<tr>
<td>messageSource</td>
<td>MessageSource 对象</td>
<td>国际化文案</td>
</tr>
<tr>
<td>lifecycleProcessor</td>
<td>LifecycleProcessor 对象</td>
<td>Lifecycle Bean 处理器</td>
</tr>
<tr>
<td>applicationEventMulticaster</td>
<td>ApplicationEventMulticaster 对象</td>
<td>Spring 事件广播器</td>
</tr>
</tbody>
</table>
<p>注解驱动 Spring 应用上下文内建可查找的依赖（部分）</p>
<table>
<thead>
<tr>
<th>Bean 实例</th>
<th>使用场景</th>
<th>Bean 名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConfigurationClassPostProcessor 对象</td>
<td>处理 Spring 配置类</td>
<td><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code></td>
</tr>
<tr>
<td>AutowiredAnnotationBeanPostProcessor 对象</td>
<td>处理 @Autowired 以及 @Value注解</td>
<td><code>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</code></td>
</tr>
<tr>
<td>CommonAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JSR-250 注解，如 @PostConstruct 等</td>
<td><code>org.springframework.context.annotation.internalCommonAnnotationProcessor</code></td>
</tr>
<tr>
<td>EventListenerMethodProcessor对象</td>
<td>处理标注 @EventListener 的Spring 事件监听方法</td>
<td><code>org.springframework.context.event.internalEventListenerProcessor</code></td>
</tr>
<tr>
<td>DefaultEventListenerFactory 对象</td>
<td>@EventListener 事件监听方法适配为 ApplicationListener</td>
<td><code>org.springframework.context.event.internalEventListenerFactory</code></td>
</tr>
<tr>
<td>PersistenceAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JPA 注解场景</td>
<td><code>org.springframework.context.annotation.internalPersistenceAnnotationProcessor</code></td>
</tr>
</tbody>
</table>
<h2 id="依赖查找中的经典异常">依赖查找中的经典异常</h2>
<p>BeansException 子类型</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>触发条件（举例）</th>
<th>场景举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoSuchBeanDefinitionException</td>
<td>当查找 Bean 不存在于 IoC 容器时</td>
<td>BeanFactory#getBean<br/>ObjectFactory#getObject</td>
</tr>
<tr>
<td>NoUniqueBeanDefinitionException</td>
<td>类型依赖查找时，IoC 容器存在多个 Bean 实例</td>
<td>BeanFactory#getBean(Class)</td>
</tr>
<tr>
<td>BeanInstantiationException</td>
<td>当 Bean 所对应的类型非具体类时</td>
<td>BeanFactory#getBean</td>
</tr>
<tr>
<td>BeanCreationException</td>
<td>当 Bean 初始化过程中</td>
<td>Bean 初始化方法执行异常时</td>
</tr>
<tr>
<td>BeanDefinitionStoreException</td>
<td>当 BeanDefinition 配置元信息非法时</td>
<td>XML 配置资源无法打开时</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Bean基础]]></title>
        <id>https://k-21d.github.io/post/spring-bean-ji-chu/</id>
        <link href="https://k-21d.github.io/post/spring-bean-ji-chu/">
        </link>
        <updated>2020-01-27T12:18:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义spring-bean">定义Spring Bean</h2>
<ul>
<li>什么是BeanDefinition？</li>
<li>BeanDefinition是Spring Framework中定义Bean的配置元信息接口，包含：
<ul>
<li>Bean的类名</li>
<li>Bean行为配置元素，如作用域、自动绑定的模式、生命周期回调等</li>
<li>其他Bean引用，又可成为合作者（Collaborators）或者依赖（Dependencies）</li>
<li>配置设置，比如Bean属性（Properties）</li>
</ul>
</li>
</ul>
<h2 id="beandefinition元信息">BeanDefinition元信息</h2>
<table>
<thead>
<tr>
<th>属性 （Property ）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td>Bean 全类名，必须是具体类，不能用抽象类或接口</td>
</tr>
<tr>
<td>Name</td>
<td>Bean 的名称或者 ID</td>
</tr>
<tr>
<td>Scope</td>
<td>Bean 的作用域（如：singleton、prototype 等）</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td>Bean 构造器参数（用于依赖注入）</td>
</tr>
<tr>
<td>Properties</td>
<td>Bean 属性设置（用于依赖注入）</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>Bean 自动绑定模式（如：通过名称 byName）</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>Bean 延迟初始化模式（延迟和非延迟）</td>
</tr>
<tr>
<td>Initialization method</td>
<td>Bean 初始化回调方法名称</td>
</tr>
<tr>
<td>Destruction method</td>
<td>Bean 销毁回调方法名称</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>BeanDefinition 构建</p>
<ul>
<li>
<p>通过 <code>BeanDefinitionBuilder</code></p>
<pre><code>BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
beanDefinitionBuilder.addPropertyValue(&quot;id&quot;,44);
beanDefinitionBuilder.addPropertyValue(&quot;name&quot;,&quot;json&quot;);
//获取 BeanDefinition 实例
AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();
//BeanDefinition并非Bean终态，可以自定义修改
</code></pre>
</li>
<li>
<p>通过 <code>AbstractBeanDefinition</code> 以及派生类</p>
<pre><code>GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
genericBeanDefinition.setBeanClass(User.class);
MutablePropertyValues propertyValues = new MutablePropertyValues();
propertyValues.addPropertyValue(&quot;id&quot;,4);
propertyValues.addPropertyValue(&quot;name&quot;,&quot;kvein&quot;);
genericBeanDefinition.setPropertyValues(propertyValues);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="命名spring-bean">命名Spring Bean</h2>
<h3 id="bean-的名称">Bean 的名称</h3>
<blockquote>
<p>每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一 的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。</p>
</blockquote>
<blockquote>
<p>在基于 XML 的配置元信息中，开发人员可用 id 或者 name 属性来规定 Bean 的 标识符。通常 Bean 的 标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。</p>
</blockquote>
<blockquote>
<p>Bean 的 id 或 name 属性并非必须制定，如果留空的话，容器会为 Bean 自动生成一个唯一的 名称。Bean的命名尽管没有限制，不过官方建议采用驼峰的方式，更符合 Java 的命名约定。</p>
</blockquote>
<h3 id="bean-名称生成器beannamegenerator">Bean 名称生成器（BeanNameGenerator）</h3>
<p>由 Spring Framework 2.0.3 引入，框架內建两种实现：</p>
<ul>
<li>
<p><code>DefaultBeanNameGenerator</code>：默认通用 BeanNameGenerator 实现</p>
<pre><code>public class DefaultBeanNameGenerator implements BeanNameGenerator {

	public static final DefaultBeanNameGenerator INSTANCE = new DefaultBeanNameGenerator();

	@Override
	public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {
		return BeanDefinitionReaderUtils.generateBeanName(definition, registry);
	}
}
</code></pre>
</li>
<li>
<p><code>AnnotationBeanNameGenerator</code>：基于注解扫描的 BeanNameGenerator 实现，起始于 Spring Framework 2.5，关联的官方文档：</p>
</li>
</ul>
<blockquote>
<p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by java.beans.Introspector.decapitalize (which Spring uses here).</p>
</blockquote>
<h2 id="spring-bean的别名">Spring Bean的别名</h2>
<p>Bean 别名（Alias）的价值</p>
<ul>
<li>复用现有的 <code>BeanDefinition</code></li>
<li>更具有场景化的命名方法，比如：</li>
</ul>
<pre><code>&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt; 
&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;
</code></pre>
<h2 id="注册spring-bean">注册Spring Bean</h2>
<h3 id="beandefinition-注册">BeanDefinition 注册</h3>
<ul>
<li>
<p>XML 配置元信息</p>
<ul>
<li><code>&lt;bean name=”...” ... /&gt;</code></li>
</ul>
</li>
<li>
<p>Java 注解配置元信息</p>
<ul>
<li>
<p><code>@Bean</code></p>
<pre><code> @Bean(name = {&quot;xxx&quot;,&quot;yyy&quot;})
</code></pre>
</li>
<li>
<p><code>@Component</code></p>
</li>
<li>
<p><code>@Import</code></p>
</li>
</ul>
</li>
<li>
<p>Java API 配置元信息</p>
<ul>
<li>
<p>命名方式：<code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></p>
<pre><code class="language-java">public static void registerBeanDefinition(BeanDefinitionRegistry registry,String beanName,Class&lt;?&gt; beanClass){
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(beanClass);
        beanDefinitionBuilder.addPropertyValue(&quot;id&quot;,2L).addPropertyValue(&quot;name&quot;,&quot;yy&quot;);
        registry.registerBeanDefinition(beanName,beanDefinitionBuilder.getBeanDefinition());
}
</code></pre>
</li>
<li>
<p>非命名方式：<code>BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,Be anDefinitionRegistry)</code></p>
<pre><code>public static void registerBeanDeinition(BeanDefinitionRegistry registry,Class&lt;?&gt; beanClass){
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(beanClass);
        	   beanDefinitionBuilder.addPropertyValue(&quot;id&quot;,2L).addPropertyValue(&quot;name&quot;,&quot;yy&quot;);
        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(),registry);
}
</code></pre>
</li>
<li>
<p>配置类方式：<code>AnnotatedBeanDefinitionReader#register(Class...)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="外部单例对象注册">外部单例对象注册</h3>
<ul>
<li>Java API 配置元信息
<ul>
<li><code>SingletonBeanRegistry#registerSingleton</code></li>
</ul>
</li>
</ul>
<h2 id="实例化-spring-bean">实例化 Spring Bean</h2>
<ul>
<li>Bean 实例化（Instantiation）
<ul>
<li>常规方式
<ul>
<li>通过构造器（配置元信息：XML、Java 注解和 Java API ）</li>
<li>通过静态工厂方法（配置元信息：XML 和 Java API ）</li>
<li>通过 Bean 工厂方法（配置元信息：XML和 Java API ）</li>
<li>通过 FactoryBean（配置元信息：XML、Java 注解和 Java API ）</li>
</ul>
</li>
<li>特殊方式
<ul>
<li>通过 <code>ServiceLoaderFactoryBean</code>（配置元信息：XML、Java 注解和 Java API ）</li>
<li>通过 <code>AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)</code></li>
<li>通过 <code>BeanDefinitionRegistry#registerBeanDefinition(String, BeanDefinition)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="初始化-spring-bean">初始化 Spring Bean</h2>
<h3 id="bean-初始化initialization">Bean 初始化（Initialization）</h3>
<ul>
<li><code>@PostConstruct</code> 标注方法</li>
<li>实现 InitializingBean 接口的 <code>afterPropertiesSet()</code> 方法</li>
<li>自定义初始化方法
<ul>
<li>XML 配置：<code>&lt;bean init-method=”init” ... /&gt;</code></li>
<li>Java 注解：<code>@Bean(initMethod=”init”)</code></li>
<li>Java API：<code>AbstractBeanDefinition#setInitMethodName(String)</code></li>
</ul>
</li>
</ul>
<p>这些方法的执行顺序是怎样？</p>
<blockquote>
<p><code>@PostConstruct</code> -&gt; <code>afterPropertiesSet()</code> -&gt; 自定义初始化方法</p>
</blockquote>
<h2 id="延迟初始化-spring-bean">延迟初始化 Spring Bean</h2>
<h3 id="bean-延迟初始化lazy-initialization">Bean 延迟初始化（Lazy Initialization）</h3>
<ul>
<li>XML 配置：<code>&lt;bean lazy-init=”true” ... /&gt;</code></li>
<li>Java 注解：<code>@Lazy(true)</code></li>
</ul>
<p>非延时加载在Spring应用上下文启动完成后，被初始化；延时加载在Spring上下文启动后再加载。</p>
<pre><code>//refresh()
// Instantiate all remaining (non-lazy-init) singletons.
finishBeanFactoryInitialization(beanFactory);
</code></pre>
<h2 id="销毁-spring-bean">销毁 Spring Bean</h2>
<ul>
<li>
<p>@PreDestroy 标注方法</p>
</li>
<li>
<p>实现 DisposableBean 接口的 destroy() 方法</p>
</li>
<li>
<p>自定义销毁方法</p>
<ul>
<li>XML 配置：&lt;bean destroy=”destroy” ... /&gt;</li>
<li>Java 注解：@Bean(destroy=”destroy”)</li>
<li>Java API：AbstractBeanDefinition#setDestroyMethodName(String)</li>
</ul>
<blockquote>
<p>@PreDestroy -&gt; DisposableBean# destroy() -&gt; 自定义销毁方法</p>
</blockquote>
</li>
</ul>
<h2 id="垃圾回收-spring-bean">垃圾回收 Spring Bean</h2>
<ul>
<li>关闭 Spring 容器（应用上下文）</li>
<li>执行 GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC容器概述]]></title>
        <id>https://k-21d.github.io/post/spring-ioc-rong-qi-gai-shu/</id>
        <link href="https://k-21d.github.io/post/spring-ioc-rong-qi-gai-shu/">
        </link>
        <updated>2020-01-20T07:15:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spring-ioc依赖查找">Spring IoC依赖查找</h2>
<h3 id="根据bean名称查找">根据Bean名称查找</h3>
<h4 id="实时查找">实时查找</h4>
<p><code>User user = (User) beanFactory.getBean(&quot;user&quot;);</code></p>
<h4 id="延时查找">延时查找</h4>
<pre><code>ObjectFactory&lt;User&gt; objectFactory = (ObjectFactory&lt;User&gt;) beanFactory.getBean(&quot;objectFactory&quot;);
User user = objectFactory.getObject();
</code></pre>
<h3 id="根据bean类型查找">根据Bean类型查找</h3>
<h4 id="单个bean对象">单个Bean对象</h4>
<p><code>User user = beanFactory.getBean(User.class);</code></p>
<h4 id="集合bean对象">集合Bean对象</h4>
<pre><code>if (beanFactory instanceof ListableBeanFactory){
    ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;
    Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);
}
</code></pre>
<h3 id="根据bean名称类型查找">根据Bean名称+类型查找</h3>
<h3 id="根据java注解查找">根据Java注解查找</h3>
<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
<pre><code class="language-Java">private static void lookupByAnnotation(BeanFactory beanFactory) {
    if (beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;
        Map&lt;String, Object&gt; beansWithAnnotation = listableBeanFactory.getBeansWithAnnotation(Super.class);
        System.out.println(&quot;@Super:&quot;+beansWithAnnotation);
    }
}
</code></pre>
<h2 id="spring-ioc依赖注入">Spring IoC依赖注入</h2>
<h3 id="根据bean名称注入">根据Bean名称注入</h3>
<h3 id="根据bean类型注入">根据Bean类型注入</h3>
<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
<h3 id="注入容器内建bean对象">注入容器内建Bean对象</h3>
<h3 id="注入非bean对象">注入非Bean对象</h3>
<h3 id="注入类型">注入类型</h3>
<ul>
<li>实时注入</li>
<li>延时注入</li>
</ul>
<h2 id="spring-ioc依赖来源">Spring IoC依赖来源</h2>
<pre><code>public class UserRepository {
    private Collection&lt;User&gt; users; //自定义bean
    private BeanFactory beanFactory; //内建非Bean对象（依赖）
    private ObjectFactory&lt;ApplicationContext&gt; objectFactory;
    public BeanFactory getBeanFactory() {
        return beanFactory;
    }
    public void setBeanFactory(BeanFactory beanFactory) {
        this.beanFactory = beanFactory;
    }
    public ObjectFactory&lt;ApplicationContext&gt; getObjectFactory() {
        return objectFactory;
    }
    public void setObjectFactory(ObjectFactory&lt;ApplicationContext&gt; objectFactory) {
        this.objectFactory = objectFactory;
    }
    public Collection&lt;User&gt; getUsers() {
        return users;
    }
    public void setUsers(Collection&lt;User&gt; users) {
        this.users = users;
    }
}
</code></pre>
<h3 id="自定义bean">自定义Bean</h3>
<pre><code>UserRepository userRepository = beanFactory.getBean(&quot;userRepository&quot;, UserRepository.class);
</code></pre>
<h3 id="依赖注入内建依赖">依赖注入（内建依赖）</h3>
<p><code>userRepository.getBeanFactory();</code></p>
<h3 id="容器内建依赖">容器内建依赖</h3>
<p><code>Environment environment = beanFactory.getBean(Environment.class);</code></p>
<h2 id="spring-ioc配置元信息">Spring Ioc配置元信息</h2>
<h3 id="bean-定义配置">Bean 定义配置</h3>
<ul>
<li>基于XMl文件</li>
<li>基于Properties文件</li>
<li>基于Java注解</li>
<li>基于Java API</li>
</ul>
<h3 id="ioc容器配置">IoC容器配置</h3>
<ul>
<li>基于XMl文件</li>
<li>基于Java注解</li>
<li>基于Java API</li>
</ul>
<h3 id="外部化属性配置">外部化属性配置</h3>
<ul>
<li>基于Java注解</li>
</ul>
<h2 id="spring-ioc容器">Spring IoC容器</h2>
<ul>
<li>BeanFactory和ApplicationContext</li>
</ul>
<h2 id="spring-应用上下文">Spring 应用上下文</h2>
<ul>
<li>ApplicaitonContext除了IoC容器角色，还有提供：
<ul>
<li>面向切面</li>
<li>配置元信息</li>
<li>资源管理</li>
<li>事件</li>
<li>国际化</li>
<li>注解</li>
<li>Environment抽象</li>
</ul>
</li>
</ul>
<p><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html">spring doc</a></p>
<h2 id="使用spring-ioc容器">使用Spring IoC容器</h2>
<ul>
<li>BeanFactory是Spring底层Ioc容器</li>
</ul>
<pre><code>//创建BeanFactory容器
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
//XML配置文件 ClassPath路径
String location = &quot;classpath:/META-INF/dependency-lookup-context.xml&quot;;
//加载配置
reader.loadBeanDefinitions(location);
</code></pre>
<ul>
<li>ApplicaitonContext事具备应用特性的BeanFactory超集</li>
</ul>
<pre><code>//创建BeanFactory容器
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
//将当前类作为配置类
applicationContext.register(AnnotationApplicationConetxtAsIoCContainerDemo.class);
//启动应用上下文
applicationContext.refresh();
</code></pre>
<h2 id="spring-ioc容器生命周期">Spring IoC容器生命周期</h2>
<ul>
<li>启动<pre><code>	@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
</code></pre>
</li>
<li>运行</li>
<li>停止<pre><code>	@Override
	public void close() {
		synchronized (this.startupShutdownMonitor) {
			doClose();
			// If we registered a JVM shutdown hook, we don't need it anymore now:
			// We've already explicitly closed the context.
			if (this.shutdownHook != null) {
				try {
					Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
				}
				catch (IllegalStateException ex) {
					// ignore - VM is already shutting down
				}
			}
		}
	}
</code></pre>
</li>
</ul>
<h2 id="beanfactory和factorybean">BeanFactory和FactoryBean</h2>
<pre><code>public interface FactoryBean&lt;T&gt; {

	String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;
	
	@Nullable
	T getObject() throws Exception;

	@Nullable
	Class&lt;?&gt; getObjectType();

	default boolean isSingleton() {
		return true;
	}
}

</code></pre>
<ul>
<li>BeanFactory是IoC底层容器</li>
<li>FactoryBean 是 创建 Bean 的一种方式，帮助实现复杂的初始化逻辑</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重新认识IoC]]></title>
        <id>https://k-21d.github.io/post/chong-xin-ren-shi-ioc/</id>
        <link href="https://k-21d.github.io/post/chong-xin-ren-shi-ioc/">
        </link>
        <updated>2020-01-15T09:16:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ioc-发展简介">IoC 发展简介</h1>
<h2 id="什么是-ioc">什么是 IoC ？</h2>
<blockquote>
<p>In software engineering, inversion of control (IoC) is a programming principle. IoC inverts the flow of<br>
control as compared to traditional control flow. In IoC, custom-written portions of a computer program receive the flow of control from a generic framework. A software architecture with this design inverts control as compared to traditional procedural programming: in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic tasks, but with inversion of control, it is the framework that calls into the custom, or task-specific, code.<br>
https://en.wikipedia.org/wiki/Inversion_of_control</p>
</blockquote>
<h2 id="ioc-的简史">IoC 的简史</h2>
<ul>
<li>1983年，Richard E. Sweet 在《The Mesa Programming Environment》中提出“Hollywood<br>
Principle”（好莱坞原则）</li>
<li>1988年，Ralph E. Johnson &amp; Brian Foote 在《Designing Reusable Classes》中提出“Inversion<br>
of control”（控制反转）</li>
<li>1996年，Michael Mattsson 在《Object-Oriented Frameworks, A survey of methodological<br>
issues》中将“Inversion of control”命名为 “Hollywood principle”</li>
<li>2004年，Martin Fowler 在《Inversion of Control Containers and the Dependency Injection<br>
pattern》中提出了自己对 IoC 以及 DI 的理解</li>
<li>2005年，Martin Fowler 在 《InversionOfControl》对 IoC 做出进一步的说明</li>
</ul>
<h1 id="ioc-主要实现策略">IoC 主要实现策略</h1>
<h2 id="维基百科">维基百科</h2>
<ul>
<li>Using a service locator pattern</li>
<li>Using dependency injection, for example
<ul>
<li>Constructor injection</li>
<li>Parameter injection</li>
<li>Setter injection</li>
<li>Interface injection</li>
</ul>
</li>
<li>Using a contextualized lookup</li>
<li>Using template method design pattern</li>
<li>Using strategy design pattern</li>
</ul>
<h2 id="expert-one-on-onetm-j2eetm-development-without-ejbtm">《Expert One-on-One™ J2EE™ Development without EJB™》</h2>
<h3 id="dependency-lookup">Dependency Lookup</h3>
<blockquote>
<p>The container provides callbacks to components, and a lookup context. This is<br>
the EJB and Apache Avalon approach. It leaves the onus on each component to use container APIs to<br>
look up resources and collaborators. The Inversion of Control is limited to the container invoking<br>
callback methods that application code can use to obtain resources.</p>
</blockquote>
<h3 id="dependency-injection">Dependency Injection</h3>
<blockquote>
<p>Components do no look up; they provide plain Java methods enabling the<br>
container to resolve dependencies. The container is wholly responsible for wiring up components,<br>
passing resolved objects in to JavaBean properties or constructors. Use of JavaBean properties is<br>
called Setter Injection; use of constructor arguments is called Constructor Injection.</p>
</blockquote>
<h1 id="ioc-容器的职责">IoC 容器的职责</h1>
<ul>
<li>依赖处理
<ul>
<li>依赖查找</li>
<li>依赖注入</li>
</ul>
</li>
<li>生命周期管理
<ul>
<li>容器</li>
<li>托管的资源（Java Beans 或其他资源）</li>
</ul>
</li>
<li>配置
<ul>
<li>容器</li>
<li>外部化配置</li>
<li>托管的资源（Java Beans 或其他资源）</li>
</ul>
</li>
</ul>
<h1 id="传统-ioc-容器实现">传统 IoC 容器实现</h1>
<ul>
<li>Java SE
<ul>
<li>Java Beans</li>
<li>Java ServiceLoader SPI</li>
<li>JNDI（Java Naming and Directory Interface）</li>
</ul>
</li>
<li>Java EE
<ul>
<li>EJB（Enterprise Java Beans）</li>
<li>Servlet</li>
</ul>
</li>
<li>开源
<ul>
<li>Apache Avalon（http://avalon.apache.org/closed.html）</li>
<li>PicoContainer（http://picocontainer.com/）</li>
<li>Google Guice（https://github.com/google/guice）</li>
<li>Spring Framework（https://spring.io/projects/spring-framework）</li>
</ul>
</li>
</ul>
<h2 id="java-beans-作为-ioc-容器">Java Beans 作为 IoC 容器</h2>
<ul>
<li>特性
<ul>
<li>依赖查找</li>
<li>生命周期管理</li>
<li>配置元信息</li>
<li>事件</li>
<li>自定义</li>
<li>资源管理</li>
<li>持久化</li>
</ul>
</li>
<li>规范
<ul>
<li>JavaBeans：https://www.oracle.com/technetwork/java/javase/tech/index-jsp-138795.html</li>
<li>BeanContext：https://docs.oracle.com/javase/8/docs/technotes/guides/beans/spec/beancontext.html</li>
</ul>
</li>
</ul>
<h1 id="轻量级-ioc-容器">轻量级 IoC 容器</h1>
<ul>
<li>《Expert One-on-One™ J2EE™ Development without EJB™》认为轻量级容器的特征：
<ul>
<li>A container that can manage application code.</li>
<li>A container that is quick to start up.</li>
<li>A container that doesn't require any special deployment steps to deploy objects within it.</li>
<li>A container that has such a light footprint and minimal API dependencies that it can be run in a variety of environments.</li>
<li>A container that sets the bar for adding a managed object so low in terms of deployment effort and performance<br>
overhead that it's possible to deploy and manage fine-grained objects, as well as coarse-grained components.</li>
</ul>
</li>
<li>《Expert One-on-One™ J2EE™ Development without EJB™》认为轻量级容器的好处：
<ul>
<li>Escaping the monolithic container</li>
<li>Maximizing code reusability</li>
<li>Greater object orientation</li>
<li>Greater productivity</li>
<li>Better testability</li>
</ul>
</li>
</ul>
<h1 id="构造器注入-vs-setter-注入">构造器注入 VS. Setter 注入</h1>
<p>Spring Framework 对构造器注入与 Setter 的论点：</p>
<blockquote>
<p>“The Spring team generally advocates constructor injection, as it lets you implement application components as<br>
immutable objects and ensures that required dependencies are not null. Furthermore, constructor-injected components<br>
are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor<br>
arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to<br>
better address proper separation of concerns.</p>
</blockquote>
<blockquote>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values<br>
within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of<br>
setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.<br>
Management through JMX MBeans is therefore a compelling use case for setter injection.”</p>
</blockquote>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为 Setter 注入的优点：</p>
<ul>
<li>JavaBean properties are well supported in IDEs.</li>
<li>JavaBean properties are self-documenting.</li>
<li>JavaBean properties are inherited by subclasses without the need for any code.</li>
<li>It's possible to use the standard JavaBeans property-editor machinery for type conversions if necessary.</li>
<li>Many existing JavaBeans can be used within a JavaBean-oriented IoC container without modification.</li>
<li>If there is a corresponding getter for each setter (making the property readable, as well as writable), it is possible to ask<br>
the component for its current configuration state. This is particularly useful if we want to persist that state: for example,<br>
in an XML form or in a database. With Constructor Injection, there's no way to find the current state.</li>
<li>Setter Injection works well for objects that have default values, meaning that not all properties need to be supplied at<br>
runtime.</li>
</ul>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为 Setter 注入的缺点：</p>
<blockquote>
<p>The order in which setters are called is not expressed in any contract. Thus, we sometimes need to invoke a<br>
method after the last setter has been called to initialize the component. Spring provides the<br>
org.springframework.beans.factory.InitializingBean interface for this; it also provides the ability to invoke an<br>
arbitrary init method. However, this contract must be documented to ensure correct use outside a container.Not all the necessary setters may have been called before use. The object can thus be left partially configured.</p>
</blockquote>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为构造器注入的优点：</p>
<blockquote>
<p>Each managed object is guaranteed to be in a consistent state—fully configured—before it can be invoked in<br>
any business methods. This is the primary motivation of Constructor Injection. (However, it is possible to achieve<br>
the same result with JavaBeans via dependency checking, as Spring can optionally perform.) There's no need for<br>
initialization methods.</p>
</blockquote>
<blockquote>
<p>There may be slightly less code than results from the use of multiple JavaBean methods, although will be no<br>
difference in complexity.</p>
</blockquote>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为构造器注入的缺点：</p>
<ul>
<li>Although also a Java-language feature, multi-argument constructors are probably less common in existing code than<br>
use of JavaBean properties.</li>
<li>Java constructor arguments don't have names visible by introspection.</li>
<li>Constructor argument lists are less well supported by IDEs than JavaBean setter methods.</li>
<li>Long constructor argument lists and large constructor bodies can become unwieldy.</li>
<li>Concrete inheritance can become problematic.</li>
<li>Poor support for optional properties, compared to JavaBeans</li>
<li>Unit testing can be slightly more difficult</li>
<li>When collaborators are passed in on object construction, it becomes impossible to change the reference held in the<br>
object.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud Gateway]]></title>
        <id>https://k-21d.github.io/post/spring-cloud-gateway/</id>
        <link href="https://k-21d.github.io/post/spring-cloud-gateway/">
        </link>
        <updated>2019-03-02T13:39:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spring-cloud-gateway">Spring Cloud Gateway</h2>
<p>Spring WebFlux</p>
<p>目的：去 Servlet 化（Java EE Web 技术中心）</p>
<p>技术：Reactor + Netty + Lambda</p>
<p>最新技术：Spring Cloud Function</p>
<h3 id="取代-zuul-1x基于-servlet">取代 Zuul 1.x（基于 Servlet）</h3>
<ul>
<li>
<p>Resin Servlet 容器</p>
<ul>
<li>可以 Nginx 匹敌</li>
</ul>
</li>
<li>
<p>Tomcat Servlet 容器</p>
<ul>
<li>连接器
<ul>
<li>Java Blocking Connector</li>
<li>Java Non Blocking Connector</li>
<li>APR/native Connector</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JBoss</p>
</li>
<li>
<p>Weblogic</p>
</li>
<li>
<p>Netflix Zuul 自己的实现</p>
<ul>
<li>实现 API 不是非常友好</li>
</ul>
</li>
</ul>
<h4 id="zuul-实现原理">Zuul 实现原理</h4>
<ul>
<li><code>@Enable</code> 模块装配
<ul>
<li><code>@EnableZuulProxy</code></li>
<li>配合注解：<code>@Import</code></li>
</ul>
</li>
<li>依赖服务发现
<ul>
<li>我是谁</li>
<li>目的服务在哪里</li>
</ul>
</li>
<li>依赖服务路由
<ul>
<li>URI 映射到目的服务</li>
</ul>
</li>
<li>依赖服务熔断（可选）</li>
</ul>
<h3 id="服务发现">服务发现</h3>
<h4 id="举例说明">举例说明</h4>
<p>假设 URI : <code>/gateway/spring-cloud-server-application/say</code></p>
<p>其中 Servlet Path ：<code>/gateway</code></p>
<p><code>spring-cloud-server-application</code> 是服务的应用名称</p>
<p><code>/say</code> 是 <code>spring-cloud-server-application</code> 的服务 URI</p>
<pre><code class="language-java">/**
 * 服务网关的路由规则
 * /{service-name}/{service-uri}
 * /gateway/rest-api/hello-world-&gt; http://127.0.0.1:8080/hello-world
 */
@WebServlet(name = &quot;gateway&quot;, urlPatterns = &quot;/gateway/*&quot;)
public class GatewayServlet extends HttpServlet {

    @Autowired
    private DiscoveryClient discoveryClient;

    private ServiceInstance randomChoose(String serviceName) {
        // 获取服务实例列表（服务IP、端口、是否为HTTPS）
        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(serviceName);
        // 获得服务实例总数
        int size = serviceInstances.size();
        // 随机获取数组下标
        int index = new Random().nextInt(size);
        return serviceInstances.get(index);
    }

    @Override
    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // ${service-name}/${service-uri}
        String pathInfo = request.getPathInfo();
        String[] parts = StringUtils.split(pathInfo.substring(1), &quot;/&quot;);
        // 获取服务名称
        String serviceName = parts[0];
        // 获取服务 URI
        String serviceURI = &quot;/&quot; + parts[1];
        // 随机选择一台服务实例
        ServiceInstance serviceInstance = randomChoose(serviceName);
        // 构建目标服务 URL -&gt; scheme://ip:port/serviceURI
        String targetURL = buildTargetURL(serviceInstance, serviceURI, request);

        // 创建转发客户端
        RestTemplate restTemplate = new RestTemplate();

        // 构造 Request 实体
        RequestEntity&lt;byte[]&gt; requestEntity = null;
        try {
            requestEntity = createRequestEntity(request, targetURL);
            ResponseEntity&lt;byte[]&gt; responseEntity = restTemplate.exchange(requestEntity, byte[].class);
            writeHeaders(responseEntity, response);
            writeBody(responseEntity, response);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }
    }

    private String buildTargetURL(ServiceInstance serviceInstance, String serviceURI, HttpServletRequest request) {
        StringBuilder urlBuilder = new StringBuilder();
        urlBuilder.append(serviceInstance.isSecure() ? &quot;https://&quot; : &quot;http://&quot;)
                .append(serviceInstance.getHost()).append(&quot;:&quot;).append(serviceInstance.getPort())
                .append(serviceURI);
        String queryString = request.getQueryString();
        if (StringUtils.hasText(queryString)) {
            urlBuilder.append(&quot;?&quot;).append(queryString);
        }
        return urlBuilder.toString();
    }

    private RequestEntity&lt;byte[]&gt; createRequestEntity(HttpServletRequest request, String url) throws URISyntaxException, IOException {
        // 获取当前请求方法
        String method = request.getMethod();
        // 装换 HttpMethod
        HttpMethod httpMethod = HttpMethod.resolve(method);
        byte[] body = createRequestBody(request);
        MultiValueMap&lt;String, String&gt; headers = createRequestHeaders(request);
        RequestEntity&lt;byte[]&gt; requestEntity = new RequestEntity&lt;byte[]&gt;(body, headers, httpMethod, new URI(url));
        return requestEntity;
    }

    private MultiValueMap&lt;String, String&gt; createRequestHeaders(HttpServletRequest request) {
        HttpHeaders headers = new HttpHeaders();
        List&lt;String&gt; headerNames = Collections.list(request.getHeaderNames());
        for (String headerName : headerNames) {
            List&lt;String&gt; headerValues = Collections.list(request.getHeaders(headerName));
            for (String headerValue : headerValues) {
                headers.add(headerName, headerValue);
            }
        }
        return headers;
    }

    private byte[] createRequestBody(HttpServletRequest request) throws IOException {
        InputStream inputStream = request.getInputStream();
        return StreamUtils.copyToByteArray(inputStream);
    }


    /**
     * 输出 Body 部分
     *
     * @param responseEntity
     * @param response
     * @throws IOException
     */
    private void writeBody(ResponseEntity&lt;byte[]&gt; responseEntity, HttpServletResponse response) throws IOException {
        if (responseEntity.hasBody()) {
            byte[] body = responseEntity.getBody();
            // 输出二进值
            ServletOutputStream outputStream = response.getOutputStream();
            // 输出 ServletOutputStream
            outputStream.write(body);
            outputStream.flush();
        }
    }

    private void writeHeaders(ResponseEntity&lt;byte[]&gt; responseEntity, HttpServletResponse response) {
        // 获取相应头
        HttpHeaders httpHeaders = responseEntity.getHeaders();
        // 输出转发 Response 头
        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : httpHeaders.entrySet()) {
            String headerName = entry.getKey();
            List&lt;String&gt; headerValues = entry.getValue();
            for (String headerValue : headerValues) {
                response.addHeader(headerName, headerValue);
            }
        }
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud 服务调用]]></title>
        <id>https://k-21d.github.io/post/spring-cloud-fu-wu-diao-yong/</id>
        <link href="https://k-21d.github.io/post/spring-cloud-fu-wu-diao-yong/">
        </link>
        <updated>2019-02-16T14:47:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分析服务调用引入背景">分析服务调用引入背景</h2>
<p><code>@LoadBalanced</code> <code>RestTemplate</code> 限制</p>
<ul>
<li>面向 URL 组件，必须依赖于 主机+端口 + URI</li>
<li>并非接口编程（Spring Cloud中，需要理解应用名称+ 服务 URI）</li>
</ul>
<p><code>RestTemplate</code> 不依赖于服务接口，仅关注 REST 响应内容。</p>
<p>举例：</p>
<blockquote>
<pre><code class="language-java">lbRestTemplate.getForObject(&quot;http://&quot; + serviceName + &quot;/say?message=&quot; + message, String.class);
</code></pre>
</blockquote>
<h2 id="主要内容">主要内容</h2>
<h3 id="spring-cloud-feign-基本用法">Spring Cloud Feign 基本用法</h3>
<h4 id="spring-cloud-feign-客户端注解-feignclient">Spring Cloud Feign 客户端注解 <code>@FeignClient</code></h4>
<p>服务（应用）定位</p>
<blockquote>
<p>@FeignClient(&quot;${service.name}&quot;) // 服务提供方的应用名称</p>
</blockquote>
<p>服务 URI 定位</p>
<blockquote>
<p>注意：Spring Cloud Feign 和 OpenFeign 区别</p>
</blockquote>
<h5 id="rest-服务端框架纵向比较">REST 服务端框架纵向比较</h5>
<p>Spring Cloud Feign 是 OpenFeign 扩展，并且使用 Spring MVC 注解来做 URI 映射，比如 <code>@RequestMapping</code> 或 <code>@GetMapping</code> 之类</p>
<p>OpenFeign：灵感来自于 JAX-RS（Java REST 标准），重复发明轮子。</p>
<p>JAX-RS：<a href="https://github.com/mercyblitz/jsr/tree/master/REST">Java REST 标准</a>，可移植性高，Jersey（Servlet 容器）、Weblogic</p>
<table>
<thead>
<tr>
<th>技术栈</th>
<th>HTTP 方法</th>
<th>变量路径</th>
<th>请求参数</th>
<th>自描述消息</th>
<th>内容协商</th>
</tr>
</thead>
<tbody>
<tr>
<td>JAX-RS</td>
<td><code>@GET</code></td>
<td><code>@PathParam</code></td>
<td><code>@FormParam</code></td>
<td>@Produces(&quot;application/widgets+xml&quot;)</td>
<td></td>
</tr>
<tr>
<td>Spring Web MVC</td>
<td><code>@GetMapping</code></td>
<td><code>@PathVariable</code></td>
<td><code>@RequestParam</code></td>
<td><code>@RequestMapping(produces=&quot;application/widgets+xml&quot;)</code></td>
<td></td>
</tr>
<tr>
<td>OpenFeign</td>
<td>@RequestLine(&quot;GET...&quot;)</td>
<td><code>@Param</code></td>
<td><code>@Param</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Spring Cloud Feign</td>
<td><code>@GetMapping</code></td>
<td><code>@PathVariable</code></td>
<td><code>@RequestParam</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>zuul IP:port/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>i</mi><mi>c</mi><msub><mi>e</mi><mi>n</mi></msub><mi>a</mi><mi>m</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">service_name/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord">/</span></span></span></span>uri</p>
</blockquote>
<h4 id="rest-核心概念java-技术描述">REST 核心概念（Java 技术描述）</h4>
<h5 id="请求映射">请求映射</h5>
<p><code>@RequestMapping</code></p>
<h5 id="请求参数处理">请求参数处理</h5>
<p><code>@RequestParam</code></p>
<h5 id="请求主题处理">请求主题处理</h5>
<p><code>@RequestBody</code></p>
<h5 id="响应处理">响应处理</h5>
<p><code>@ResponseBody</code></p>
<p><code>@ResponseStatus</code></p>
<p><code>@ResponseBody</code> + <code>@ResponseStatus</code> &lt;= <code>ResponseEntity</code></p>
<h5 id="自描述消息">自描述消息</h5>
<p><code>@RequestMapping(produces=&quot;application/widgets+xml&quot;)</code></p>
<h5 id="内容协商">内容协商</h5>
<p><code>ContentNegotiationManager</code></p>
<p>理论知识：https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation</p>
<h4 id="整合-spring-cloud-feign">整合 Spring Cloud Feign</h4>
<h5 id="增加-spring-cloud-feign-依赖">增加 Spring Cloud Feign 依赖</h5>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h5 id="整合-enablefeignclients">整合 <code>@EnableFeignClients</code></h5>
<pre><code class="language-java">@SpringBootApplication // 标准 Spring Boot 应用
@EnableDiscoveryClient // 激活服务发现客户端
@EnableScheduling
@EnableFeignClients
public class SpringCloudClientApplication {

    public static void main(String[] args) {
        new SpringApplicationBuilder(SpringCloudClientApplication.class)
                .web(WebApplicationType.SERVLET)
                .run(args);
    }
}
</code></pre>
<h5 id="整合-feignclient">整合 <code>@FeignClient</code></h5>
<p>之前实现</p>
<pre><code class="language-java">    @GetMapping(&quot;/lb/invoke/{serviceName}/say&quot;) // -&gt; /say
    public String lbInvokeSay(@PathVariable String serviceName,
                              @RequestParam String message) {
        // Ribbon RestTemplate 发送请求到服务器
        // 输出响应
        return lbRestTemplate.getForObject(&quot;http://&quot; + serviceName + &quot;/say?message=&quot; + message, String.class);
    }
</code></pre>
<p>整合 <code>@FeignClient</code> 实现</p>
<pre><code class="language-java">@FeignClient(name = &quot;spring-cloud-server-application&quot;)
public interface SayingService {

    @GetMapping(&quot;/say&quot;)
    String say(@RequestParam(&quot;message&quot;) String message);

}
</code></pre>
<p>注入 <code>SayingService</code></p>
<pre><code class="language-java">    @Autowired
    private SayingService sayingService;
</code></pre>
<p>调用 <code>SayingService</code></p>
<pre><code class="language-java">    @GetMapping(&quot;/feign/say&quot;)
    public String feignSay(@RequestParam String message) {
        return sayingService.say(message);
    }
</code></pre>
<p>启动 ZK 服务器</p>
<p>启动 <code>spring-cloud-server-application</code></p>
<p>启动 <code>spring-cloud-client-application</code></p>
<h4 id="实现自定义-restclient模拟-feignclient">实现自定义 RestClient（模拟 <code>@FeignClient</code>）</h4>
<h5 id="spring-cloud-feign-编程模型特征">Spring Cloud Feign 编程模型特征</h5>
<ul>
<li><code>@Enable</code> 模块驱动</li>
<li><code>@*Client</code> 绑定客户端接口，指定应用名称</li>
<li>客户端接口指定请求映射 <code>@RequetMapping</code></li>
<li>客户端接口指定请求参数 <code>@RequetParam</code>
<ul>
<li>必须指定 <code>@RequestParam#value()</code></li>
</ul>
</li>
<li><code>@Autowired</code> 客户端接口是一个代理</li>
</ul>
<h5 id="实现-restclient">实现 <code>@RestClient</code></h5>
<pre><code class="language-java">/**
 * Rest Client 注解
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RestClient {

    /**
     * REST 服务应用名称
     * @return
     */
    String name();
}
</code></pre>
<h5 id="实现-restclient-服务接口">实现 <code>@RestClient</code> 服务接口</h5>
<pre><code class="language-java">@RestClient(name = &quot;spring-cloud-server-application&quot;)
public interface SayingRestService {

    @GetMapping(&quot;/say&quot;)
    String say(@RequestParam(&quot;message&quot;) String message);

}
</code></pre>
<h5 id="实现-enable-模块">实现 <code>@Enable</code> 模块</h5>
<pre><code class="language-java">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Import(RestClientsRegistrar.class)
public @interface EnableRestClient {

    /**
     * 指定 @RestClient 接口
     * @return
     */
    Class&lt;?&gt;[] clients() default {};
}
</code></pre>
<h5 id="实现-restclientsregistrar">实现 <code>RestClientsRegistrar</code></h5>
<ul>
<li>指定 <code>@RestClient</code> 服务接口
<ul>
<li>识别 <code>@RestClient</code></li>
<li>过滤所有 <code>@RequestMapping</code> 方法</li>
</ul>
</li>
<li>将 <code>@RestClient</code> 服务接口注册 Bean
<ul>
<li>
<h2 id="restclient-服务接口形成代理实现"><code>@RestClient</code> 服务接口形成代理实现</h2>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud 服务熔断]]></title>
        <id>https://k-21d.github.io/post/spring-cloud-fu-wu-rong-duan/</id>
        <link href="https://k-21d.github.io/post/spring-cloud-fu-wu-rong-duan/">
        </link>
        <updated>2019-02-10T14:35:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="spring-cloud-hystrix-client">Spring Cloud Hystrix Client</h3>
<blockquote>
<p>注意：方法签名</p>
<ul>
<li>访问限定符</li>
<li>方法返回类型</li>
<li>方法名称</li>
<li>方法参数
<ul>
<li>方法数量</li>
<li>方法类型+顺序</li>
<li><s>方法名称（编译时预留，IDE，Debug）</s></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="实现服务熔断future">实现服务熔断（Future）</h3>
<h4 id="低级版本无容错实现">低级版本（无容错实现）</h4>
<pre><code class="language-java">    private final ExecutorService executorService = Executors.newSingleThreadExecutor();

    /**
     * 简易版本
     *
     * @param message
     * @return
     * @throws InterruptedException
     */
    @GetMapping(&quot;/say2&quot;)
    public String say2(@RequestParam String message) throws Exception {
        Future&lt;String&gt; future = executorService.submit(() -&gt; {
            return doSay2(message);
        });
        // 100 毫秒超时
        String returnValue = future.get(100, TimeUnit.MILLISECONDS);
        return returnValue;
    }
</code></pre>
<h4 id="低级版本带容错实现">低级版本+（带容错实现）</h4>
<pre><code class="language-java">    private final ExecutorService executorService = Executors.newSingleThreadExecutor();

    /**
     * 简易版本
     *
     * @param message
     * @return
     * @throws InterruptedException
     */
    @GetMapping(&quot;/say2&quot;)
    public String say2(@RequestParam String message) throws Exception {
        Future&lt;String&gt; future = executorService.submit(() -&gt; {
            return doSay2(message);
        });
        // 100 毫秒超时
        String returnValue = null;
        try {
            returnValue = future.get(100, TimeUnit.MILLISECONDS);
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            // 超级容错 = 执行错误 或 超时
            returnValue = errorContent(message);
        }
        return returnValue;
    }
</code></pre>
<h4 id="中级版本">中级版本</h4>
<pre><code class="language-java">    /**
     * 中级版本
     *
     * @param message
     * @return
     * @throws InterruptedException
     */
    @GetMapping(&quot;/middle/say&quot;)
    public String middleSay(@RequestParam String message) throws Exception {
        Future&lt;String&gt; future = executorService.submit(() -&gt; {
            return doSay2(message);
        });
        // 100 毫秒超时
        String returnValue = null;

        try {
            returnValue = future.get(100, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            future.cancel(true); // 取消执行
            throw e;
        }
        return returnValue;
    }
</code></pre>
<pre><code class="language-java">@RestControllerAdvice(assignableTypes = ServerController.class)
public class CircuitBreakerControllerAdvice {

    @ExceptionHandler
    public void onTimeoutException(TimeoutException timeoutException,
                                   Writer writer) throws IOException {
        writer.write(errorContent(&quot;&quot;)); // 网络 I/O 被容器
        writer.flush();
        writer.close();
    }

    public String errorContent(String message) {
        return &quot;Fault&quot;;
    }

}
</code></pre>
<h4 id="高级版本无注解实现">高级版本（无注解实现）</h4>
<pre><code class="language-java">    /**
     * 高级版本
     *
     * @param message
     * @return
     * @throws InterruptedException
     */
    @GetMapping(&quot;/advanced/say&quot;)
    public String advancedSay(@RequestParam String message) throws Exception {
        return doSay2(message);
    }
</code></pre>
<pre><code class="language-java">@Aspect
@Component
public class ServerControllerAspect {

    private ExecutorService executorService = newFixedThreadPool(20);

    @Around(&quot;execution(* com.k21d.micro.services.spring.cloud.&quot; +
            &quot;server.controller.ServerController.advancedSay(..)) &amp;&amp; args(message) &quot;)
    public Object advancedSayInTimeout(ProceedingJoinPoint point, String message) throws Throwable {
        Future&lt;Object&gt; future = executorService.submit(() -&gt; {
            Object returnValue = null;
            try {
                returnValue = point.proceed(new Object[]{message});
            } catch (Throwable ex) {
            }
            return returnValue;
        });

        Object returnValue = null;
        try {
            returnValue = future.get(100, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            future.cancel(true); // 取消执行
            returnValue = errorContent(&quot;&quot;);
        }
        return returnValue;
    }

    public String errorContent(String message) {
        return &quot;Fault&quot;;
    }

    @PreDestroy
    public void destroy() {
        executorService.shutdown();
    }

}
</code></pre>
<h4 id="高级版本带注解实现">高级版本（带注解实现）</h4>
<ul>
<li>Aspect 注解实现</li>
</ul>
<pre><code class="language-java">    @Around(&quot;execution(* com.k21d.micro.services.spring.cloud.&quot; +
            &quot;server.controller.ServerController.advancedSay2(..)) &amp;&amp; args(message) &amp;&amp; @annotation(circuitBreaker)&quot;)
    public Object advancedSay2InTimeout(ProceedingJoinPoint point,
                                        String message,
                                        CircuitBreaker circuitBreaker) throws Throwable {
        long timeout = circuitBreaker.timeout();
        return doInvoke(point, message, timeout);
    }
</code></pre>
<ul>
<li>反射API 实现</li>
</ul>
<pre><code class="language-java">    @Around(&quot;execution(* com.k21d.micro.services.spring.cloud.&quot; +
            &quot;server.controller.ServerController.advancedSay2(..)) &amp;&amp; args(message) &quot;)
    public Object advancedSay2InTimeout(ProceedingJoinPoint point,
                                        String message) throws Throwable {

        long timeout = -1;
        if (point instanceof MethodInvocationProceedingJoinPoint) {
            MethodInvocationProceedingJoinPoint methodPoint = (MethodInvocationProceedingJoinPoint) point;
            MethodSignature signature = (MethodSignature) methodPoint.getSignature();
            Method method = signature.getMethod();
            CircuitBreaker circuitBreaker = method.getAnnotation(CircuitBreaker.class);
            timeout = circuitBreaker.timeout();
        }
        return doInvoke(point, message, timeout);
    }
</code></pre>
<h4 id="高级版本信号灯实现-单机版限流方案">高级版本（信号灯实现 = 单机版限流方案）</h4>
<pre><code class="language-java">    @Around(&quot;execution(* com.k21d.micro.services.spring.cloud.&quot; +
            &quot;server.controller.ServerController.advancedSay3(..))&quot; +
            &quot; &amp;&amp; args(message)&quot; +
            &quot; &amp;&amp; @annotation(circuitBreaker) &quot;)
    public Object advancedSay3InSemaphore(ProceedingJoinPoint point,
                                          String message,
                                          SemaphoreCircuitBreaker circuitBreaker) throws Throwable {
        int value = circuitBreaker.value();
        if (semaphore == null) {
            semaphore = new Semaphore(value);
        }
        Object returnValue = null;
        try {
            if (semaphore.tryAcquire()) {
                returnValue = point.proceed(new Object[]{message});
                Thread.sleep(1000);
            } else {
                returnValue = errorContent(&quot;&quot;);
            }
        } finally {
            semaphore.release();
        }

        return returnValue;

    }

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Cloud 负载均衡]]></title>
        <id>https://k-21d.github.io/post/spring-cloud-fu-zai-jun-heng/</id>
        <link href="https://k-21d.github.io/post/spring-cloud-fu-zai-jun-heng/">
        </link>
        <updated>2019-02-02T12:31:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="resttemplate-原理与扩展">RestTemplate 原理与扩展</h3>
<p>Spring 核心 HTTP 消息转换器 <code>HttpMessageConverter</code></p>
<p>REST 自描述消息：媒体类型（<code>MediaType</code>）， text/html;text/xml;application/json</p>
<p>HTTP 协议特点：纯文本协议，自我描述</p>
<ul>
<li>
<p>REST 服务端</p>
</li>
<li>
<p>REST 客户端</p>
<p>反序列化：文本（通讯） -&gt; 对象（程序使用）</p>
<p>序列化：对象 -&gt; 文本</p>
</li>
</ul>
<h4 id="httpmessageconverter-分析"><code>HttpMessageConverter</code> 分析</h4>
<h5 id="判断是否可读可写">判断是否可读可写</h5>
<pre><code class="language-java">public interface HttpMessageConverter&lt;T&gt; {

	boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);

	
	boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType);
}
</code></pre>
<p>clazz = Person.class</p>
<h5 id="当前支持的媒体类型">当前支持的媒体类型</h5>
<pre><code class="language-java">public interface HttpMessageConverter&lt;T&gt; {	
	List&lt;MediaType&gt; getSupportedMediaTypes();
}
</code></pre>
<p><code>MappingJackson2HttpMessageConverter</code></p>
<h5 id="反序列化">反序列化</h5>
<pre><code class="language-java">public interface HttpMessageConverter&lt;T&gt; {	
	T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;
}
</code></pre>
<p>特别提醒：Spring Web MVC  依赖 Servlet，Spring 在早期设计时，它就考虑到了去 Servlet 化。</p>
<p>HttpInputMessage 类似于 HttpServletRequest</p>
<pre><code class="language-java">public interface HttpInputMessage extends HttpMessage {

	InputStream getBody() throws IOException;
    
	// 来自于 HttpMessage
	HttpHeaders getHeaders();

}
</code></pre>
<p>类比 <code>HttpServletRequest</code></p>
<pre><code class="language-java">public interface HttpServletRequest {    
    
    // 来自于 ServletRequest
	public ServletInputStream getInputStream() throws IOException;
    
    public Enumeration&lt;String&gt; getHeaders(String name);
 
    public Enumeration&lt;String&gt; getHeaderNames();
}
</code></pre>
<p><code>RestTemplate</code>利用 <code>HttpMessageConverter</code> 对一定媒体类型序列化和反序列化</p>
<p>JSON</p>
<p>XML</p>
<p>TEXT</p>
<p>它不依赖于 Servlet API，它自定义实现</p>
<p>对于服务端而言，将 Servlet API 适配成 <code>HttpInputMessage</code> 以及 <code>HttpOutputMessage</code></p>
<p><code>RestTemplate</code> 对应多个 <code>HttpMessageConverter</code>，那么如何决策正确媒体类型。</p>
<h4 id="resttemplate-在-httpmessageconverter-设计">RestTemplate 在 <code>HttpMessageConverter</code> 设计</h4>
<pre><code class="language-java">public class RestTemplate extends InterceptingHttpAccessor implements RestOperations {
    ...
    // List 形式
    private final List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = new ArrayList&lt;&gt;();
    ...
    public RestTemplate() {
		this.messageConverters.add(new ByteArrayHttpMessageConverter());
		this.messageConverters.add(new StringHttpMessageConverter());
		this.messageConverters.add(new ResourceHttpMessageConverter(false));
		this.messageConverters.add(new SourceHttpMessageConverter&lt;&gt;());
		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());

		if (romePresent) {
			this.messageConverters.add(new AtomFeedHttpMessageConverter());
			this.messageConverters.add(new RssChannelHttpMessageConverter());
		}

		if (jackson2XmlPresent) {
			this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter());
		}
		else if (jaxb2Present) {
			this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());
		}

		if (jackson2Present) {
			this.messageConverters.add(new MappingJackson2HttpMessageConverter());
		}
		else if (gsonPresent) {
			this.messageConverters.add(new GsonHttpMessageConverter());
		}
		else if (jsonbPresent) {
			this.messageConverters.add(new JsonbHttpMessageConverter());
		}

		if (jackson2SmilePresent) {
			this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter());
		}
		if (jackson2CborPresent) {
			this.messageConverters.add(new MappingJackson2CborHttpMessageConverter());
		}
	}
}
</code></pre>
<ul>
<li>添加内建 <code>HttpMessageConvertor</code> 实现</li>
<li>有条件地添加第三方库<code>HttpMessageConvertor</code> 整合实现</li>
</ul>
<blockquote>
<p>问题场景一： http://localhost:8080/person -&gt; XML 而不是 Jackson</p>
<p>Postman 、<code>curl</code> 场景最为明显</p>
<p>没有传递请求头，无从选择媒体类型</p>
<p>假设 Person 既能被 XML 读取，有能被 JSON 读取</p>
</blockquote>
<blockquote>
<p>Content-Type: text/html; charset=utf-8</p>
</blockquote>
<h4 id="resttemplate-扩展">RestTemplate 扩展</h4>
<h5 id="扩展-http-客户端">扩展 HTTP 客户端</h5>
<ul>
<li>ClientHttpRequestFactory
<ul>
<li>Spring 实现
<ul>
<li>SimpleClientHttpRequestFactory</li>
</ul>
</li>
<li>HttpClient
<ul>
<li>HttpComponentsClientHttpRequestFactory</li>
</ul>
</li>
<li>OkHttp
<ul>
<li>OkHttp3ClientHttpRequestFactory</li>
<li>OkHttpClientHttpRequestFactory</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>微服务要使用轻量级的协议，比如 REST</p>
<p>Spring Cloud <code>RestTemplate</code> 核心的调用器</p>
<p>企业整合模型（叫好，不叫座） -&gt; Spring Integration</p>
<p>DDD</p>
<h4 id="resttemplate-整合-zookeeper"><code>RestTemplate</code> 整合 Zookeeper</h4>
<h3 id="netflix-ribbon">Netflix Ribbon</h3>
<p><code>@LoadBalanced</code> 利用注解来过滤，注入方和声明方同时使用</p>
<h4 id="负载均衡客户端">负载均衡客户端</h4>
<p><code>ServiceInstanceChooser</code></p>
<p><code>LoadBalancerClient</code></p>
<h4 id="负载均衡上下文">负载均衡上下文</h4>
<p><code>LoadBalancerContext</code></p>
<h4 id="负载均衡规则">负载均衡规则</h4>
<p><code>ILoadBalancer</code></p>
<p>Q: @Qualifier为什么选择了自定义的RestTemplate而不是lbRestTemplate呢？是按照先后set的吗</p>
<p><code>@Qualifier</code> “父”注解，<code>@Qualifier</code> , <code>@LoadBalanced</code></p>
<p>@Autowired</p>
<p>Collection<Object></p>
<p>List<Object></p>
<p>Set<Object></p>
]]></content>
    </entry>
</feed>