<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://k-21d.github.io</id>
    <title>学习博客</title>
    <updated>2020-05-08T09:18:14.784Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://k-21d.github.io"/>
    <link rel="self" href="https://k-21d.github.io/atom.xml"/>
    <subtitle>Java Blog</subtitle>
    <logo>https://k-21d.github.io/images/avatar.png</logo>
    <icon>https://k-21d.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 学习博客</rights>
    <entry>
        <title type="html"><![CDATA[Spring Bean生命周期]]></title>
        <id>https://k-21d.github.io/post/spring-bean-sheng-ming-zhou-qi/</id>
        <link href="https://k-21d.github.io/post/spring-bean-sheng-ming-zhou-qi/">
        </link>
        <updated>2020-03-26T04:54:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spring-bean-元信息配置阶段">Spring Bean 元信息配置阶段</h2>
<p>BeanDefinition 配置</p>
<ul>
<li>面向资源
<ul>
<li>XML 配置</li>
<li>Properties 资源配置</li>
</ul>
</li>
<li>面向注解</li>
<li>面向 API</li>
</ul>
<h2 id="spring-bean-元信息解析阶段">Spring Bean 元信息解析阶段</h2>
<h3 id="面向资源-beandefinition-解析">面向资源 BeanDefinition 解析</h3>
<ul>
<li>BeanDefinitionReader</li>
<li>XML 解析器 - BeanDefinitionParser</li>
</ul>
<h3 id="面向注解-beandefinition-解析">面向注解 BeanDefinition 解析</h3>
<ul>
<li>AnnotatedBeanDefinitionReader</li>
</ul>
<h2 id="spring-bean-注册阶段">Spring Bean 注册阶段</h2>
<ul>
<li>BeanDefinition 注册接口
<ul>
<li>BeanDefinitionRegistry</li>
</ul>
</li>
</ul>
<h2 id="spring-beandefinition-合并阶段">Spring BeanDefinition 合并阶段</h2>
<ul>
<li>BeanDefinition 合并 -&gt;RootBeanDefinition
<ul>
<li>父子 BeanDefinition 合并
<ul>
<li>当前 BeanFactory 查找</li>
<li>层次性 BeanFactory 查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-class-加载阶段">Spring Bean Class 加载阶段</h2>
<ul>
<li>ClassLoader 类加载</li>
<li>Java Security 安全控制</li>
<li>ConfigurableBeanFactory 临时 ClassLoader</li>
</ul>
<h2 id="spring-bean-实例化前阶段">Spring Bean 实例化前阶段</h2>
<ul>
<li>
<p>非主流生命周期 - Bean 实例化前阶段 ,提前生成像代理对象的方式来替换掉默认的Spring IoC中的内容</p>
<ul>
<li>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</li>
</ul>
<pre><code>	@Nullable
	protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {
		for (BeanPostProcessor bp : getBeanPostProcessors()) {
			if (bp instanceof InstantiationAwareBeanPostProcessor) {
				InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
				Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
				if (result != null) {
					return result;
				}
			}
		}
		return null;
	}
</code></pre>
</li>
</ul>
<h2 id="spring-bean-实例化阶段">Spring Bean 实例化阶段</h2>
<pre><code>		try {
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
			}
			return beanInstance;
		}
</code></pre>
<ul>
<li>实例化方式</li>
<li>传统实例化方式
<ul>
<li>实例化策略 - InstantiationStrategy</li>
</ul>
</li>
<li>构造器依赖注入</li>
</ul>
<pre><code>	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {//判断是否是单例
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {//返回BeanWrapper
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = instanceWrapper.getWrappedInstance();
		Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
		if (beanType != NullBean.class) {
			mbd.resolvedTargetType = beanType;
		}

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							&quot;Post-processing of merged bean definition failed&quot;, ex);
				}
				mbd.postProcessed = true;
			}
		}

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
						&quot;' to allow for resolving potential circular references&quot;);
			}
			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			populateBean(beanName, mbd, instanceWrapper);
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
			}
		}

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								&quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								&quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
								&quot;wrapped. This means that said other beans do not use the final version of the &quot; +
								&quot;bean. This is often the result of over-eager type matching - consider using &quot; +
								&quot;'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
		}

		return exposedObject;
	}
</code></pre>
<h2 id="spring-bean-实例化后阶段">Spring Bean 实例化后阶段</h2>
<p>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</p>
<h2 id="spring-bean-属性赋值前阶段">Spring Bean 属性赋值前阶段</h2>
<ul>
<li>Bean 属性值元信息
<ul>
<li>PropertyValues</li>
</ul>
</li>
<li>Bean 属性赋值前回调
<ul>
<li>Spring 1.2 - 5.0：InstantiationAwareBeanPostProcessor#postProcessPropertyValues</li>
<li>Spring 5.1：InstantiationAwareBeanPostProcessor#postProcessProperties</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-aware接口回调阶段">Spring Bean Aware接口回调阶段</h2>
<ul>
<li>Spring Aware 接口 （按调用顺序排列）
<ul>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationContextAware</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-初始化前阶段">Spring Bean 初始化前阶段</h2>
<ul>
<li>已完成
<ul>
<li>Bean 实例化</li>
<li>Bean 属性赋值</li>
<li>Bean Aware 接口回调</li>
</ul>
</li>
<li>方法回调
<ul>
<li>BeanPostProcessor#postProcessBeforeInitialization</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-初始化阶段">Spring Bean 初始化阶段</h2>
<ul>
<li>Bean 初始化（Initialization）
<ul>
<li>@PostConstruct 标注方法</li>
<li>实现 InitializingBean 接口的 afterPropertiesSet() 方法</li>
<li>自定义初始化方法</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-初始化后阶段">Spring Bean 初始化后阶段</h2>
<ul>
<li>方法回调
<ul>
<li>BeanPostProcessor#postProcessAfterInitialization</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-初始化完成阶段">Spring Bean 初始化完成阶段</h2>
<ul>
<li>方法回调
<ul>
<li>Spring 4.1 +：SmartInitializingSingleton#afterSingletonsInstantiated</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-销毁前阶段">Spring Bean 销毁前阶段</h2>
<ul>
<li>方法回调
<ul>
<li>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-销毁阶段">Spring Bean 销毁阶段</h2>
<ul>
<li>Bean 销毁（Destroy）
<ul>
<li>@PreDestroy 标注方法</li>
<li>实现 DisposableBean 接口的 destroy() 方法</li>
<li>自定义销毁方法</li>
</ul>
</li>
</ul>
<h2 id="spring-bean-垃圾收集">Spring Bean 垃圾收集</h2>
<ul>
<li>Bean 垃圾回收（GC）
<ul>
<li>关闭 Spring 容器（应用上下文）</li>
<li>执行 GC</li>
<li>Spring Bean 覆盖的 finalize() 方法被回调</li>
</ul>
</li>
</ul>
<h2 id="面试题">面试题</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC 依赖来源]]></title>
        <id>https://k-21d.github.io/post/spring-ioc-yi-lai-lai-yuan/</id>
        <link href="https://k-21d.github.io/post/spring-ioc-yi-lai-lai-yuan/">
        </link>
        <updated>2020-02-12T12:18:17.000Z</updated>
        <content type="html"><![CDATA[<p>Spring IOC的三种依赖来源：</p>
<ul>
<li>
<p>自定义注册的Spring bean，通过xml、注解或者api注册BeanDefination创建的</p>
</li>
<li>
<p>内建的Spring bean，通过registerSingleton()创建的</p>
</li>
<li>
<p>内建的可注入的依赖，通过registerResolveDependency()创建</p>
<p>后续如果我们需要往Spring容器里放入一些非Spring托管的bean但又可以被依赖注入的, 可以通过registerResolveDependency() API实现</p>
</li>
</ul>
<h2 id="依赖查找的来源">依赖查找的来源</h2>
<h3 id="查找来源">查找来源</h3>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td><bean id="user" class="org.geekbang...User"></td>
</tr>
<tr>
<td></td>
<td>@Bean public User user(){...}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API 实现</td>
</tr>
</tbody>
</table>
<h3 id="spring-內建-beandefintion">Spring 內建 BeanDefintion</h3>
<table>
<thead>
<tr>
<th>Bean 实例</th>
<th>使用场景</th>
<th>Bean 名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConfigurationClassPostProcessor 对象</td>
<td>处理 Spring 配置类</td>
<td><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code></td>
</tr>
<tr>
<td>AutowiredAnnotationBeanPostProcessor 对象</td>
<td>处理 @Autowired 以及 @Value注解</td>
<td><code>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</code></td>
</tr>
<tr>
<td>CommonAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JSR-250 注解，如 @PostConstruct 等</td>
<td><code>org.springframework.context.annotation.internalCommonAnnotationProcessor</code></td>
</tr>
<tr>
<td>EventListenerMethodProcessor对象</td>
<td>处理标注 @EventListener 的Spring 事件监听方法</td>
<td><code>org.springframework.context.event.internalEventListenerProcessor</code></td>
</tr>
<tr>
<td>DefaultEventListenerFactory 对象</td>
<td>@EventListener 事件监听方法适配为 ApplicationListener</td>
<td><code>org.springframework.context.event.internalEventListenerFactory</code></td>
</tr>
<tr>
<td>PersistenceAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JPA 注解场景</td>
<td><code>org.springframework.context.annotation.internalPersistenceAnnotationProcessor</code></td>
</tr>
</tbody>
</table>
<h3 id="spring-內建单例对象">Spring 內建单例对象</h3>
<table>
<thead>
<tr>
<th>Bean 名称</th>
<th>Bean 实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>Environment 对象</td>
<td>外部化配置以及 Profiles</td>
</tr>
<tr>
<td>systemProperties</td>
<td>java.util.Properties 对象</td>
<td>java.util.Properties 对象</td>
</tr>
<tr>
<td>systemEnvironment</td>
<td>java.util.Map 对象</td>
<td>操作系统环境变量</td>
</tr>
<tr>
<td>messageSource</td>
<td>MessageSource 对象</td>
<td>国际化文案</td>
</tr>
<tr>
<td>lifecycleProcessor</td>
<td>LifecycleProcessor 对象</td>
<td>Lifecycle Bean 处理器</td>
</tr>
<tr>
<td>applicationEventMulticaster</td>
<td>ApplicationEventMulticaster 对象</td>
<td>Spring 事件广播器</td>
</tr>
</tbody>
</table>
<h2 id="依赖注入的来源">依赖注入的来源</h2>
<h3 id="注入来源">注入来源</h3>
<table>
<thead>
<tr>
<th>来源</th>
<th>配置元数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td><bean id="user" class="org.geekbang...User"></td>
</tr>
<tr>
<td></td>
<td>@Bean public User user(){...}</td>
</tr>
<tr>
<td></td>
<td>BeanDefinitionBuilder</td>
</tr>
<tr>
<td>单例对象</td>
<td>API 实现</td>
</tr>
<tr>
<td>非Spring容器管理对象</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="spring-容器管理和游离对象">Spring 容器管理和游离对象</h2>
<p>依赖对象</p>
<table>
<thead>
<tr>
<th>来源</th>
<th>Spring Bean 对象</th>
<th>生命周期管理</th>
<th>配置元信息</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spring BeanDefinition</td>
<td>是</td>
<td>是</td>
<td>有</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>单体对象</td>
<td>是</td>
<td>否</td>
<td>无</td>
<td>依赖查找、依赖注入</td>
</tr>
<tr>
<td>Resolvable Dependency</td>
<td>否</td>
<td>否</td>
<td>无</td>
<td>依赖注入</td>
</tr>
</tbody>
</table>
<h3 id="spring-beandefinition-作为依赖来源">Spring BeanDefinition 作为依赖来源</h3>
<ul>
<li>元数据：BeanDefinition</li>
<li>注册：BeanDefinitionRegistry#registerBeanDefinition</li>
<li>类型：延迟和非延迟</li>
<li>顺序：Bean 生命周期顺序按照注册顺序</li>
</ul>
<h3 id="单例对象作为依赖来源">单例对象作为依赖来源</h3>
<h4 id="要素">要素</h4>
<ul>
<li>来源：外部普通 Java 对象（不一定是 POJO）</li>
<li>注册：SingletonBeanRegistry#registerSingleton</li>
</ul>
<h4 id="限制">限制</h4>
<ul>
<li>无生命周期管理</li>
<li>无法实现延迟初始化 Bean</li>
</ul>
<h3 id="非-spring-容器管理对象作为依赖来源">非 Spring 容器管理对象作为依赖来源</h3>
<h4 id="要素-2">要素</h4>
<ul>
<li>注册：ConfigurableListableBeanFactory#registerResolvableDependency</li>
</ul>
<h4 id="限制-2">限制</h4>
<ul>
<li>无生命周期管理</li>
<li>无法实现延迟初始化 Bean</li>
<li>无法通过依赖查找</li>
</ul>
<h3 id="外部化配置作为依赖来源">外部化配置作为依赖来源</h3>
<h4 id="要素-3">要素</h4>
<ul>
<li>类型：非常规 Spring 对象依赖来源</li>
</ul>
<h4 id="限制-3">限制</h4>
<ul>
<li>无生命周期管理</li>
<li>无法实现延迟初始化 Bean</li>
<li>无法通过依赖查找</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC 注入]]></title>
        <id>https://k-21d.github.io/post/spring-ioc-zhu-ru/</id>
        <link href="https://k-21d.github.io/post/spring-ioc-zhu-ru/">
        </link>
        <updated>2020-02-06T03:39:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="依赖注入的模式和类型">依赖注入的模式和类型</h2>
<h3 id="手动模式">手动模式</h3>
<p>配置或者编程的方式，提前安排注入规则</p>
<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
<h3 id="自动模式">自动模式</h3>
<p>实现方提供依赖自动关联的方式，按照內建的注入规则</p>
<ul>
<li>Autowiring（自动绑定）</li>
</ul>
<h3 id="依赖注入类型">依赖注入类型</h3>
<table>
<thead>
<tr>
<th>依赖注入类型</th>
<th>配置元数据举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Setter 方法</td>
<td><proeprty name="user" ref="userBean" /></td>
</tr>
<tr>
<td>构造器</td>
<td><constructor-arg name="user" ref="userBean" /></td>
</tr>
<tr>
<td>字段</td>
<td>@Autowired User user;</td>
</tr>
<tr>
<td>方法</td>
<td>@Autowired public void user(User user) { ... }</td>
</tr>
<tr>
<td>接口回调</td>
<td>class MyBean implements BeanFactoryAware { ... }</td>
</tr>
</tbody>
</table>
<h2 id="自动绑定autowiring">自动绑定（Autowiring）</h2>
<h3 id="官方说明">官方说明</h3>
<blockquote>
<p>The Spring container can autowire relationships between collaborating beans. You can let Spring<br>
resolve collaborators (other beans) automatically for your bean by inspecting the contents of the<br>
ApplicationContext.</p>
</blockquote>
<h3 id="优点">优点</h3>
<ul>
<li>Autowiring can significantly reduce the need to specify properties or constructor arguments.</li>
<li>Autowiring can update a configuration as your objects evolve.</li>
</ul>
<h2 id="自动绑定autowiring模式">自动绑定（Autowiring）模式</h2>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>no</td>
<td>默认值，未激活 Autowiring，需要手动指定依赖注入对象</td>
</tr>
<tr>
<td>byName</td>
<td>根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>byType</td>
<td>根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性</td>
</tr>
<tr>
<td>constructor</td>
<td>constructor</td>
</tr>
</tbody>
</table>
<h2 id="自动绑定autowiring限制和不足">自动绑定（Autowiring）限制和不足</h2>
<p>Limitations and Disadvantages of Autowiring 小节</p>
<p>https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-frameworkreference/core.html#beans-autowired-exceptions</p>
<h2 id="setter-方法依赖注入">Setter 方法依赖注入</h2>
<h3 id="手动模式-2">手动模式</h3>
<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
<h3 id="自动模式-2">自动模式</h3>
<ul>
<li>byName</li>
<li>byType</li>
</ul>
<h2 id="构造器依赖注入">构造器依赖注入</h2>
<h3 id="手动模式-3">手动模式</h3>
<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
<h3 id="自动模式-3">自动模式</h3>
<ul>
<li>constructor</li>
</ul>
<h2 id="字段注入">字段注入</h2>
<h3 id="手动模式-4">手动模式</h3>
<ul>
<li>Java 注解配置元信息
<ul>
<li>@Autowired  :会忽略静态字段</li>
<li>@Resource</li>
<li>@Inject（可选）</li>
</ul>
</li>
</ul>
<h2 id="方法注入">方法注入</h2>
<h3 id="手动模式-5">手动模式</h3>
<ul>
<li>Java 注解配置元信息
<ul>
<li>@Autowired</li>
<li>@Resource</li>
<li>@Inject（可选）</li>
<li>@Bean</li>
</ul>
</li>
</ul>
<h2 id="回调注入">回调注入</h2>
<p>Aware 系列接口回调</p>
<table>
<thead>
<tr>
<th>內建接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BeanFactoryAware</td>
<td>获取 IoC 容器 - BeanFactory</td>
</tr>
<tr>
<td>ApplicationContextAware</td>
<td>获取 Spring 应用上下文 - ApplicationContext 对象</td>
</tr>
<tr>
<td>EnvironmentAware</td>
<td>获取 Environment 对象</td>
</tr>
<tr>
<td>ResourceLoaderAware</td>
<td>获取资源加载器 对象 - ResourceLoader</td>
</tr>
<tr>
<td>BeanClassLoaderAware</td>
<td>获取加载当前 Bean Class 的 ClassLoader</td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>获取当前 Bean 的名称</td>
</tr>
<tr>
<td>MessageSourceAware</td>
<td>获取 MessageSource 对象，用于 Spring 国际化</td>
</tr>
<tr>
<td>ApplicationEventPublisherAware</td>
<td>获取 ApplicationEventPublishAware 对象，用于 Spring 事件</td>
</tr>
<tr>
<td>EmbeddedValueResolverAware</td>
<td>获取 StringValueResolver 对象，用于占位符处理</td>
</tr>
</tbody>
</table>
<h2 id="依赖注入类型选择">依赖注入类型选择</h2>
<ul>
<li>低依赖：构造器注入</li>
<li>多依赖：Setter方法注入</li>
<li>便利性：字段注入</li>
<li>声明类：方法注入</li>
</ul>
<h3 id="基础类型注入">基础类型注入</h3>
<ul>
<li>原生类型（Primitive）：boolean、byte、char、short、int、float、long、double</li>
<li>标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li>
<li>常规类型（General）：Object、String、TimeZone、Calendar、Optional</li>
<li>Spring类型：Resource、InputSource、Formatter等</li>
</ul>
<h3 id="集合类型注入">集合类型注入</h3>
<ul>
<li>数组类型（Array）：原生类型、标量类型、常规类型、Spring类型</li>
<li>集合类型（Collection）
<ul>
<li>Collection：List、Set（SortedSet、Navigable、EnumSet）</li>
<li>Map：Properties</li>
</ul>
</li>
</ul>
<h3 id="限定注入">限定注入</h3>
<ul>
<li>使用注解@Qualifier限定
<ul>
<li>通过Bean名称限定</li>
<li>通过分组限定</li>
</ul>
</li>
<li>基于注解@Qualifier拓展限定
<ul>
<li>自定义注解-如Spring  Cloud @LoadBalanced</li>
</ul>
</li>
</ul>
<h3 id="延迟依赖注入">延迟依赖注入</h3>
<ul>
<li>使用API ObjectFactory延迟注入
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
<li>使用API ObjectProvider延迟注入（推荐）
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
</ul>
<h2 id="依赖处理过程">依赖处理过程</h2>
<h3 id="基础知识">基础知识</h3>
<ul>
<li>
<p>入口：<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code></p>
<pre><code>	@Override
	@Nullable
	public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
			@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
		if (Optional.class == descriptor.getDependencyType()) {
			return createOptionalDependency(descriptor, requestingBeanName);
		}
		else if (ObjectFactory.class == descriptor.getDependencyType() ||
				ObjectProvider.class == descriptor.getDependencyType()) {
			return new DependencyObjectProvider(descriptor, requestingBeanName);
		}
		else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
			return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
		}
		else {
			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
					descriptor, requestingBeanName);
			if (result == null) {
				result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
			}
			return result;
		}
	}
</code></pre>
</li>
<li>
<p>依赖描述符：<code>org.springframework.beans.factory.config.DependencyDescriptor</code></p>
</li>
<li>
<p>自定绑定候选对象处理器：<code>org.springframework.beans.factory.support.AutowireCandidateResolver</code></p>
</li>
</ul>
<h3 id="autowired-注入原理">@Autowired 注入原理</h3>
<ul>
<li>元信息解析</li>
<li>依赖查找</li>
<li>依赖注入（字段、方法）</li>
</ul>
<p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p>
<pre><code>		@Override
		protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
			Field field = (Field) this.member;
			Object value;
			if (this.cached) {
				value = resolvedCachedArgument(beanName, this.cachedFieldValue);
			}
			else {
				DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
				desc.setContainingClass(bean.getClass());
				Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(1);
				Assert.state(beanFactory != null, &quot;No BeanFactory available&quot;);
				TypeConverter typeConverter = beanFactory.getTypeConverter();
				try {
					value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
				}
				catch (BeansException ex) {
					throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
				}
				synchronized (this) {
					if (!this.cached) {
						if (value != null || this.required) {
							this.cachedFieldValue = desc;
							registerDependentBeans(beanName, autowiredBeanNames);
							if (autowiredBeanNames.size() == 1) {
								String autowiredBeanName = autowiredBeanNames.iterator().next();
								if (beanFactory.containsBean(autowiredBeanName) &amp;&amp;
										beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
									this.cachedFieldValue = new ShortcutDependencyDescriptor(
											desc, autowiredBeanName, field.getType());
								}
							}
						}
						else {
							this.cachedFieldValue = null;
						}
						this.cached = true;
					}
				}
			}
			if (value != null) {
				ReflectionUtils.makeAccessible(field);
				field.set(bean, value);
			}
		}
	}
</code></pre>
<h3 id="jsr-330-inject-注入原理">JSR-330 @Inject 注入原理</h3>
<pre><code>javax.inject.Inject
</code></pre>
<h3 id="java通用注解注入原理">Java通用注解注入原理</h3>
<p>CommonAnnotationBeanPostProcessor</p>
<ul>
<li>注入注解
<ul>
<li><code>java.x.xml.ws.WebServiceRef</code></li>
<li><code>javax.ejb.EJB</code></li>
<li><code>javax.annotation.Resource</code></li>
</ul>
</li>
<li>生命周期注解
<ul>
<li><code>javax.annotation.PostConstruct</code></li>
<li><code>javax.annotation.PreDestroy</code></li>
</ul>
</li>
</ul>
<h3 id="自定义依赖注入注解">自定义依赖注入注解</h3>
<ul>
<li>
<p>基于AutowiredAnnotationBeanPostProcessor实现</p>
<pre><code>@Bean
public static AutowiredAnnotationBeanPostProcessor beanPostProcessor(){
	AutowiredAnnotationBeanPostProcessor beanPostProcessor = new AutowiredAnnotationBeanPostProcessor();
	//替换原有的注解处理
	beanPostProcessor.setAutowiredAnnotationType(自定义注解.class);
	return beanPostProcessor;
}
</code></pre>
</li>
<li>
<p>自定义实现</p>
<ul>
<li>生命周期处理
<ul>
<li>InstantiationAwareBeanPostProcessor</li>
<li>MergedBeanDefinitionPostProcessor</li>
</ul>
</li>
<li>元数据
<ul>
<li>InjectedElement</li>
<li>InjectionMetadata</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC依赖查找]]></title>
        <id>https://k-21d.github.io/post/spring-yi-lai-cha-zhao/</id>
        <link href="https://k-21d.github.io/post/spring-yi-lai-cha-zhao/">
        </link>
        <updated>2020-02-01T13:47:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="单一类型依赖查找">单一类型依赖查找</h2>
<p>单一类型依赖查找接口 - BeanFactory</p>
<h3 id="根据-bean-名称查找">根据 Bean 名称查找</h3>
<ul>
<li>getBean(String)</li>
<li>Spring 2.5 覆盖默认参数：getBean(String,Object...)</li>
</ul>
<h3 id="根据-bean-类型查找">根据 Bean 类型查找</h3>
<ul>
<li>
<p>Bean 实时查找</p>
<ul>
<li>Spring 3.0 getBean(Class)</li>
<li>Spring 4.1 覆盖默认参数：getBean(Class,Object...)</li>
</ul>
</li>
<li>
<p>Spring 5.1 Bean 延迟查找</p>
<ul>
<li>
<p>getBeanProvider(Class)</p>
<pre><code>public class ObjectProviderDemo {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
        applicationContext.register(ObjectProviderDemo.class);
        applicationContext.refresh();
        lookupByObjectProvider(applicationContext);
        applicationContext.close();
    }

    @Bean
    public String helloWorld(){
        //方法名就是Bean的名称
        return &quot;Hello,World&quot;;
    }
    private static void lookupByObjectProvider(AnnotationConfigApplicationContext applicationContext) {
        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);
        System.out.println(beanProvider.getObject());
    }
}
</code></pre>
</li>
<li>
<p>getBeanProvider(ResolvableType)</p>
</li>
</ul>
</li>
</ul>
<h3 id="根据-bean-名称-类型查找getbeanstringclass">根据 Bean 名称 + 类型查找：getBean(String,Class)</h3>
<h2 id="集合类型依赖查找">集合类型依赖查找</h2>
<p>集合类型依赖查找接口 - ListableBeanFactory</p>
<h3 id="根据-bean-类型查找-2">根据 Bean 类型查找</h3>
<ul>
<li>获取同类型 Bean 名称列表
<ul>
<li>getBeanNamesForType(Class)</li>
<li>Spring 4.2 getBeanNamesForType(ResolvableType)</li>
</ul>
</li>
<li>获取同类型 Bean 实例列表
<ul>
<li>getBeansOfType(Class) 以及重载方法</li>
</ul>
</li>
</ul>
<h3 id="通过注解类型查找">通过注解类型查找</h3>
<ul>
<li>Spring 3.0 获取标注类型 Bean 名称列表
<ul>
<li>getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt;)</li>
</ul>
</li>
<li>Spring 3.0 获取标注类型 Bean 实例列表
<ul>
<li>getBeansWithAnnotation(Class&lt;? extends Annotation&gt;)</li>
</ul>
</li>
<li>Spring 3.0 获取指定名称 + 标注类型 Bean 实例
<ul>
<li>findAnnotationOnBean(String,Class&lt;? extends Annotation&gt;)</li>
</ul>
</li>
</ul>
<h2 id="层次性依赖查找">层次性依赖查找</h2>
<p>层次性依赖查找接口 - HierarchicalBeanFactory</p>
<h3 id="双亲-beanfactorygetparentbeanfactory">双亲 BeanFactory：getParentBeanFactory()</h3>
<h3 id="层次性查找">层次性查找</h3>
<ul>
<li>根据 Bean 名称查找
<ul>
<li>基于 containsLocalBean 方法实现</li>
</ul>
</li>
<li>根据 Bean 类型查找实例列表
<ul>
<li>单一类型：BeanFactoryUtils#beanOfType</li>
<li>集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors</li>
</ul>
</li>
<li>根据 Java 注解查找名称列表
<ul>
<li>集合类型：BeanFactoryUtils#beansOfTypeIncludingAncestors</li>
</ul>
</li>
</ul>
<h2 id="延迟依赖查找">延迟依赖查找</h2>
<ul>
<li>
<p><code>org.springframework.beans.factory.ObjectFactory</code></p>
</li>
<li>
<p><code>org.springframework.beans.factory.ObjectProvider</code></p>
<ul>
<li>
<p>Spring 5 对 Java 8 特性扩展</p>
<ul>
<li>
<p>函数式接口</p>
<ul>
<li>
<p>getIfAvailable(Supplier)</p>
<pre><code>ObjectProvider&lt;User&gt; beanProvider = applicationContext.getBeanProvider(User.class);
User user = beanProvider.getIfAvailable(User::createUser);
</code></pre>
</li>
<li>
<p>ifAvailable(Consumer)</p>
</li>
</ul>
</li>
<li>
<p>Stream 扩展 - stream()</p>
<pre><code>@Bean
public String message(){
   return &quot;Message&quot;;
}
private static void looupByStreamOps(AnnotationConfigApplicationContext applicationContext) {
        ObjectProvider&lt;String&gt; beanProvider = applicationContext.getBeanProvider(String.class);
        beanProvider.stream().forEach(System.out::print);
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全依赖查找">安全依赖查找</h2>
<p>依赖查找安全性对比</p>
<table>
<thead>
<tr>
<th>依赖查找类型</th>
<th style="text-align:left">代表实现</th>
<th style="text-align:center">是否安全</th>
</tr>
</thead>
<tbody>
<tr>
<td>单一类型查找</td>
<td style="text-align:left">BeanFactory#getBean</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">ObjectFactory#getObject</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">ObjectProvider#getIfAvailable</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td>集合类型查找</td>
<td style="text-align:left">ListableBeanFactory#getBeansOfType</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">ObjectProvider#stream</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 BeanFactory 接口</p>
<h2 id="内建可查找的依赖">内建可查找的依赖</h2>
<p>AbstractApplicationContext 内建可查找的依赖</p>
<table>
<thead>
<tr>
<th>Bean 名称</th>
<th>Bean 实例</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>environment</td>
<td>Environment 对象</td>
<td>外部化配置以及 Profiles</td>
</tr>
<tr>
<td>systemProperties</td>
<td>java.util.Properties 对象</td>
<td>java.util.Properties 对象</td>
</tr>
<tr>
<td>systemEnvironment</td>
<td>java.util.Map 对象</td>
<td>操作系统环境变量</td>
</tr>
<tr>
<td>messageSource</td>
<td>MessageSource 对象</td>
<td>国际化文案</td>
</tr>
<tr>
<td>lifecycleProcessor</td>
<td>LifecycleProcessor 对象</td>
<td>Lifecycle Bean 处理器</td>
</tr>
<tr>
<td>applicationEventMulticaster</td>
<td>ApplicationEventMulticaster 对象</td>
<td>Spring 事件广播器</td>
</tr>
</tbody>
</table>
<p>注解驱动 Spring 应用上下文内建可查找的依赖（部分）</p>
<table>
<thead>
<tr>
<th>Bean 实例</th>
<th>使用场景</th>
<th>Bean 名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConfigurationClassPostProcessor 对象</td>
<td>处理 Spring 配置类</td>
<td><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code></td>
</tr>
<tr>
<td>AutowiredAnnotationBeanPostProcessor 对象</td>
<td>处理 @Autowired 以及 @Value注解</td>
<td><code>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</code></td>
</tr>
<tr>
<td>CommonAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JSR-250 注解，如 @PostConstruct 等</td>
<td><code>org.springframework.context.annotation.internalCommonAnnotationProcessor</code></td>
</tr>
<tr>
<td>EventListenerMethodProcessor对象</td>
<td>处理标注 @EventListener 的Spring 事件监听方法</td>
<td><code>org.springframework.context.event.internalEventListenerProcessor</code></td>
</tr>
<tr>
<td>DefaultEventListenerFactory 对象</td>
<td>@EventListener 事件监听方法适配为 ApplicationListener</td>
<td><code>org.springframework.context.event.internalEventListenerFactory</code></td>
</tr>
<tr>
<td>PersistenceAnnotationBeanPostProcessor 对象</td>
<td>（条件激活）处理 JPA 注解场景</td>
<td><code>org.springframework.context.annotation.internalPersistenceAnnotationProcessor</code></td>
</tr>
</tbody>
</table>
<h2 id="依赖查找中的经典异常">依赖查找中的经典异常</h2>
<p>BeansException 子类型</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>触发条件（举例）</th>
<th>场景举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>NoSuchBeanDefinitionException</td>
<td>当查找 Bean 不存在于 IoC 容器时</td>
<td>BeanFactory#getBean<br/>ObjectFactory#getObject</td>
</tr>
<tr>
<td>NoUniqueBeanDefinitionException</td>
<td>类型依赖查找时，IoC 容器存在多个 Bean 实例</td>
<td>BeanFactory#getBean(Class)</td>
</tr>
<tr>
<td>BeanInstantiationException</td>
<td>当 Bean 所对应的类型非具体类时</td>
<td>BeanFactory#getBean</td>
</tr>
<tr>
<td>BeanCreationException</td>
<td>当 Bean 初始化过程中</td>
<td>Bean 初始化方法执行异常时</td>
</tr>
<tr>
<td>BeanDefinitionStoreException</td>
<td>当 BeanDefinition 配置元信息非法时</td>
<td>XML 配置资源无法打开时</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Bean基础]]></title>
        <id>https://k-21d.github.io/post/spring-bean-ji-chu/</id>
        <link href="https://k-21d.github.io/post/spring-bean-ji-chu/">
        </link>
        <updated>2020-01-27T12:18:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义spring-bean">定义Spring Bean</h2>
<ul>
<li>什么是BeanDefinition？</li>
<li>BeanDefinition是Spring Framework中定义Bean的配置元信息接口，包含：
<ul>
<li>Bean的类名</li>
<li>Bean行为配置元素，如作用域、自动绑定的模式、生命周期回调等</li>
<li>其他Bean引用，又可成为合作者（Collaborators）或者依赖（Dependencies）</li>
<li>配置设置，比如Bean属性（Properties）</li>
</ul>
</li>
</ul>
<h2 id="beandefinition元信息">BeanDefinition元信息</h2>
<table>
<thead>
<tr>
<th>属性 （Property ）</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td>Bean 全类名，必须是具体类，不能用抽象类或接口</td>
</tr>
<tr>
<td>Name</td>
<td>Bean 的名称或者 ID</td>
</tr>
<tr>
<td>Scope</td>
<td>Bean 的作用域（如：singleton、prototype 等）</td>
</tr>
<tr>
<td>Constructor arguments</td>
<td>Bean 构造器参数（用于依赖注入）</td>
</tr>
<tr>
<td>Properties</td>
<td>Bean 属性设置（用于依赖注入）</td>
</tr>
<tr>
<td>Autowiring mode</td>
<td>Bean 自动绑定模式（如：通过名称 byName）</td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td>Bean 延迟初始化模式（延迟和非延迟）</td>
</tr>
<tr>
<td>Initialization method</td>
<td>Bean 初始化回调方法名称</td>
</tr>
<tr>
<td>Destruction method</td>
<td>Bean 销毁回调方法名称</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>BeanDefinition 构建</p>
<ul>
<li>
<p>通过 <code>BeanDefinitionBuilder</code></p>
<pre><code>BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User.class);
beanDefinitionBuilder.addPropertyValue(&quot;id&quot;,44);
beanDefinitionBuilder.addPropertyValue(&quot;name&quot;,&quot;json&quot;);
//获取 BeanDefinition 实例
AbstractBeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();
//BeanDefinition并非Bean终态，可以自定义修改
</code></pre>
</li>
<li>
<p>通过 <code>AbstractBeanDefinition</code> 以及派生类</p>
<pre><code>GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition();
genericBeanDefinition.setBeanClass(User.class);
MutablePropertyValues propertyValues = new MutablePropertyValues();
propertyValues.addPropertyValue(&quot;id&quot;,4);
propertyValues.addPropertyValue(&quot;name&quot;,&quot;kvein&quot;);
genericBeanDefinition.setPropertyValues(propertyValues);
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="命名spring-bean">命名Spring Bean</h2>
<h3 id="bean-的名称">Bean 的名称</h3>
<blockquote>
<p>每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一 的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。</p>
</blockquote>
<blockquote>
<p>在基于 XML 的配置元信息中，开发人员可用 id 或者 name 属性来规定 Bean 的 标识符。通常 Bean 的 标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。</p>
</blockquote>
<blockquote>
<p>Bean 的 id 或 name 属性并非必须制定，如果留空的话，容器会为 Bean 自动生成一个唯一的 名称。Bean的命名尽管没有限制，不过官方建议采用驼峰的方式，更符合 Java 的命名约定。</p>
</blockquote>
<h3 id="bean-名称生成器beannamegenerator">Bean 名称生成器（BeanNameGenerator）</h3>
<p>由 Spring Framework 2.0.3 引入，框架內建两种实现：</p>
<ul>
<li>
<p><code>DefaultBeanNameGenerator</code>：默认通用 BeanNameGenerator 实现</p>
<pre><code>public class DefaultBeanNameGenerator implements BeanNameGenerator {

	public static final DefaultBeanNameGenerator INSTANCE = new DefaultBeanNameGenerator();

	@Override
	public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {
		return BeanDefinitionReaderUtils.generateBeanName(definition, registry);
	}
}
</code></pre>
</li>
<li>
<p><code>AnnotationBeanNameGenerator</code>：基于注解扫描的 BeanNameGenerator 实现，起始于 Spring Framework 2.5，关联的官方文档：</p>
</li>
</ul>
<blockquote>
<p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by java.beans.Introspector.decapitalize (which Spring uses here).</p>
</blockquote>
<h2 id="spring-bean的别名">Spring Bean的别名</h2>
<p>Bean 别名（Alias）的价值</p>
<ul>
<li>复用现有的 <code>BeanDefinition</code></li>
<li>更具有场景化的命名方法，比如：</li>
</ul>
<pre><code>&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemA-dataSource&quot;/&gt; 
&lt;alias name=&quot;myApp-dataSource&quot; alias=&quot;subsystemB-dataSource&quot;/&gt;
</code></pre>
<h2 id="注册spring-bean">注册Spring Bean</h2>
<h3 id="beandefinition-注册">BeanDefinition 注册</h3>
<ul>
<li>
<p>XML 配置元信息</p>
<ul>
<li><code>&lt;bean name=”...” ... /&gt;</code></li>
</ul>
</li>
<li>
<p>Java 注解配置元信息</p>
<ul>
<li>
<p><code>@Bean</code></p>
<pre><code> @Bean(name = {&quot;xxx&quot;,&quot;yyy&quot;})
</code></pre>
</li>
<li>
<p><code>@Component</code></p>
</li>
<li>
<p><code>@Import</code></p>
</li>
</ul>
</li>
<li>
<p>Java API 配置元信息</p>
<ul>
<li>
<p>命名方式：<code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></p>
<pre><code class="language-java">public static void registerBeanDefinition(BeanDefinitionRegistry registry,String beanName,Class&lt;?&gt; beanClass){
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(beanClass);
        beanDefinitionBuilder.addPropertyValue(&quot;id&quot;,2L).addPropertyValue(&quot;name&quot;,&quot;yy&quot;);
        registry.registerBeanDefinition(beanName,beanDefinitionBuilder.getBeanDefinition());
}
</code></pre>
</li>
<li>
<p>非命名方式：<code>BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,Be anDefinitionRegistry)</code></p>
<pre><code>public static void registerBeanDeinition(BeanDefinitionRegistry registry,Class&lt;?&gt; beanClass){
        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(beanClass);
        	   beanDefinitionBuilder.addPropertyValue(&quot;id&quot;,2L).addPropertyValue(&quot;name&quot;,&quot;yy&quot;);
        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(),registry);
}
</code></pre>
</li>
<li>
<p>配置类方式：<code>AnnotatedBeanDefinitionReader#register(Class...)</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="外部单例对象注册">外部单例对象注册</h3>
<ul>
<li>Java API 配置元信息
<ul>
<li><code>SingletonBeanRegistry#registerSingleton</code></li>
</ul>
</li>
</ul>
<h2 id="实例化-spring-bean">实例化 Spring Bean</h2>
<ul>
<li>Bean 实例化（Instantiation）
<ul>
<li>常规方式
<ul>
<li>通过构造器（配置元信息：XML、Java 注解和 Java API ）</li>
<li>通过静态工厂方法（配置元信息：XML 和 Java API ）</li>
<li>通过 Bean 工厂方法（配置元信息：XML和 Java API ）</li>
<li>通过 FactoryBean（配置元信息：XML、Java 注解和 Java API ）</li>
</ul>
</li>
<li>特殊方式
<ul>
<li>通过 <code>ServiceLoaderFactoryBean</code>（配置元信息：XML、Java 注解和 Java API ）</li>
<li>通过 <code>AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)</code></li>
<li>通过 <code>BeanDefinitionRegistry#registerBeanDefinition(String, BeanDefinition)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="初始化-spring-bean">初始化 Spring Bean</h2>
<h3 id="bean-初始化initialization">Bean 初始化（Initialization）</h3>
<ul>
<li><code>@PostConstruct</code> 标注方法</li>
<li>实现 InitializingBean 接口的 <code>afterPropertiesSet()</code> 方法</li>
<li>自定义初始化方法
<ul>
<li>XML 配置：<code>&lt;bean init-method=”init” ... /&gt;</code></li>
<li>Java 注解：<code>@Bean(initMethod=”init”)</code></li>
<li>Java API：<code>AbstractBeanDefinition#setInitMethodName(String)</code></li>
</ul>
</li>
</ul>
<p>这些方法的执行顺序是怎样？</p>
<blockquote>
<p><code>@PostConstruct</code> -&gt; <code>afterPropertiesSet()</code> -&gt; 自定义初始化方法</p>
</blockquote>
<h2 id="延迟初始化-spring-bean">延迟初始化 Spring Bean</h2>
<h3 id="bean-延迟初始化lazy-initialization">Bean 延迟初始化（Lazy Initialization）</h3>
<ul>
<li>XML 配置：<code>&lt;bean lazy-init=”true” ... /&gt;</code></li>
<li>Java 注解：<code>@Lazy(true)</code></li>
</ul>
<p>非延时加载在Spring应用上下文启动完成后，被初始化；延时加载在Spring上下文启动后再加载。</p>
<pre><code>//refresh()
// Instantiate all remaining (non-lazy-init) singletons.
finishBeanFactoryInitialization(beanFactory);
</code></pre>
<h2 id="销毁-spring-bean">销毁 Spring Bean</h2>
<ul>
<li>
<p>@PreDestroy 标注方法</p>
</li>
<li>
<p>实现 DisposableBean 接口的 destroy() 方法</p>
</li>
<li>
<p>自定义销毁方法</p>
<ul>
<li>XML 配置：&lt;bean destroy=”destroy” ... /&gt;</li>
<li>Java 注解：@Bean(destroy=”destroy”)</li>
<li>Java API：AbstractBeanDefinition#setDestroyMethodName(String)</li>
</ul>
<blockquote>
<p>@PreDestroy -&gt; DisposableBean# destroy() -&gt; 自定义销毁方法</p>
</blockquote>
</li>
</ul>
<h2 id="垃圾回收-spring-bean">垃圾回收 Spring Bean</h2>
<ul>
<li>关闭 Spring 容器（应用上下文）</li>
<li>执行 GC</li>
<li>Spring Bean覆盖的finalize()方法被回调</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring IoC容器概述]]></title>
        <id>https://k-21d.github.io/post/spring-ioc-rong-qi-gai-shu/</id>
        <link href="https://k-21d.github.io/post/spring-ioc-rong-qi-gai-shu/">
        </link>
        <updated>2020-01-20T07:15:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="spring-ioc依赖查找">Spring IoC依赖查找</h2>
<h3 id="根据bean名称查找">根据Bean名称查找</h3>
<h4 id="实时查找">实时查找</h4>
<p><code>User user = (User) beanFactory.getBean(&quot;user&quot;);</code></p>
<h4 id="延时查找">延时查找</h4>
<pre><code>ObjectFactory&lt;User&gt; objectFactory = (ObjectFactory&lt;User&gt;) beanFactory.getBean(&quot;objectFactory&quot;);
User user = objectFactory.getObject();
</code></pre>
<h3 id="根据bean类型查找">根据Bean类型查找</h3>
<h4 id="单个bean对象">单个Bean对象</h4>
<p><code>User user = beanFactory.getBean(User.class);</code></p>
<h4 id="集合bean对象">集合Bean对象</h4>
<pre><code>if (beanFactory instanceof ListableBeanFactory){
    ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;
    Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User.class);
}
</code></pre>
<h3 id="根据bean名称类型查找">根据Bean名称+类型查找</h3>
<h3 id="根据java注解查找">根据Java注解查找</h3>
<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
<pre><code class="language-Java">private static void lookupByAnnotation(BeanFactory beanFactory) {
    if (beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;
        Map&lt;String, Object&gt; beansWithAnnotation = listableBeanFactory.getBeansWithAnnotation(Super.class);
        System.out.println(&quot;@Super:&quot;+beansWithAnnotation);
    }
}
</code></pre>
<h2 id="spring-ioc依赖注入">Spring IoC依赖注入</h2>
<h3 id="根据bean名称注入">根据Bean名称注入</h3>
<h3 id="根据bean类型注入">根据Bean类型注入</h3>
<ul>
<li>单个Bean对象</li>
<li>集合Bean对象</li>
</ul>
<h3 id="注入容器内建bean对象">注入容器内建Bean对象</h3>
<h3 id="注入非bean对象">注入非Bean对象</h3>
<h3 id="注入类型">注入类型</h3>
<ul>
<li>实时注入</li>
<li>延时注入</li>
</ul>
<h2 id="spring-ioc依赖来源">Spring IoC依赖来源</h2>
<pre><code>public class UserRepository {
    private Collection&lt;User&gt; users; //自定义bean
    private BeanFactory beanFactory; //内建非Bean对象（依赖）
    private ObjectFactory&lt;ApplicationContext&gt; objectFactory;
    public BeanFactory getBeanFactory() {
        return beanFactory;
    }
    public void setBeanFactory(BeanFactory beanFactory) {
        this.beanFactory = beanFactory;
    }
    public ObjectFactory&lt;ApplicationContext&gt; getObjectFactory() {
        return objectFactory;
    }
    public void setObjectFactory(ObjectFactory&lt;ApplicationContext&gt; objectFactory) {
        this.objectFactory = objectFactory;
    }
    public Collection&lt;User&gt; getUsers() {
        return users;
    }
    public void setUsers(Collection&lt;User&gt; users) {
        this.users = users;
    }
}
</code></pre>
<h3 id="自定义bean">自定义Bean</h3>
<pre><code>UserRepository userRepository = beanFactory.getBean(&quot;userRepository&quot;, UserRepository.class);
</code></pre>
<h3 id="依赖注入内建依赖">依赖注入（内建依赖）</h3>
<p><code>userRepository.getBeanFactory();</code></p>
<h3 id="容器内建依赖">容器内建依赖</h3>
<p><code>Environment environment = beanFactory.getBean(Environment.class);</code></p>
<h2 id="spring-ioc配置元信息">Spring Ioc配置元信息</h2>
<h3 id="bean-定义配置">Bean 定义配置</h3>
<ul>
<li>基于XMl文件</li>
<li>基于Properties文件</li>
<li>基于Java注解</li>
<li>基于Java API</li>
</ul>
<h3 id="ioc容器配置">IoC容器配置</h3>
<ul>
<li>基于XMl文件</li>
<li>基于Java注解</li>
<li>基于Java API</li>
</ul>
<h3 id="外部化属性配置">外部化属性配置</h3>
<ul>
<li>基于Java注解</li>
</ul>
<h2 id="spring-ioc容器">Spring IoC容器</h2>
<ul>
<li>BeanFactory和ApplicationContext</li>
</ul>
<h2 id="spring-应用上下文">Spring 应用上下文</h2>
<ul>
<li>ApplicaitonContext除了IoC容器角色，还有提供：
<ul>
<li>面向切面</li>
<li>配置元信息</li>
<li>资源管理</li>
<li>事件</li>
<li>国际化</li>
<li>注解</li>
<li>Environment抽象</li>
</ul>
</li>
</ul>
<p><a href="https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html">spring doc</a></p>
<h2 id="使用spring-ioc容器">使用Spring IoC容器</h2>
<ul>
<li>BeanFactory是Spring底层Ioc容器</li>
</ul>
<pre><code>//创建BeanFactory容器
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
//XML配置文件 ClassPath路径
String location = &quot;classpath:/META-INF/dependency-lookup-context.xml&quot;;
//加载配置
reader.loadBeanDefinitions(location);
</code></pre>
<ul>
<li>ApplicaitonContext事具备应用特性的BeanFactory超集</li>
</ul>
<pre><code>//创建BeanFactory容器
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
//将当前类作为配置类
applicationContext.register(AnnotationApplicationConetxtAsIoCContainerDemo.class);
//启动应用上下文
applicationContext.refresh();
</code></pre>
<h2 id="spring-ioc容器生命周期">Spring IoC容器生命周期</h2>
<ul>
<li>启动<pre><code>	@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn(&quot;Exception encountered during context initialization - &quot; +
							&quot;cancelling refresh attempt: &quot; + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
</code></pre>
</li>
<li>运行</li>
<li>停止<pre><code>	@Override
	public void close() {
		synchronized (this.startupShutdownMonitor) {
			doClose();
			// If we registered a JVM shutdown hook, we don't need it anymore now:
			// We've already explicitly closed the context.
			if (this.shutdownHook != null) {
				try {
					Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
				}
				catch (IllegalStateException ex) {
					// ignore - VM is already shutting down
				}
			}
		}
	}
</code></pre>
</li>
</ul>
<h2 id="beanfactory和factorybean">BeanFactory和FactoryBean</h2>
<pre><code>public interface FactoryBean&lt;T&gt; {

	String OBJECT_TYPE_ATTRIBUTE = &quot;factoryBeanObjectType&quot;;
	
	@Nullable
	T getObject() throws Exception;

	@Nullable
	Class&lt;?&gt; getObjectType();

	default boolean isSingleton() {
		return true;
	}
}

</code></pre>
<ul>
<li>BeanFactory是IoC底层容器</li>
<li>FactoryBean 是 创建 Bean 的一种方式，帮助实现复杂的初始化逻辑</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重新认识IoC]]></title>
        <id>https://k-21d.github.io/post/chong-xin-ren-shi-ioc/</id>
        <link href="https://k-21d.github.io/post/chong-xin-ren-shi-ioc/">
        </link>
        <updated>2020-01-15T09:16:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="ioc-发展简介">IoC 发展简介</h1>
<h2 id="什么是-ioc">什么是 IoC ？</h2>
<blockquote>
<p>In software engineering, inversion of control (IoC) is a programming principle. IoC inverts the flow of<br>
control as compared to traditional control flow. In IoC, custom-written portions of a computer program receive the flow of control from a generic framework. A software architecture with this design inverts control as compared to traditional procedural programming: in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic tasks, but with inversion of control, it is the framework that calls into the custom, or task-specific, code.<br>
https://en.wikipedia.org/wiki/Inversion_of_control</p>
</blockquote>
<h2 id="ioc-的简史">IoC 的简史</h2>
<ul>
<li>1983年，Richard E. Sweet 在《The Mesa Programming Environment》中提出“Hollywood<br>
Principle”（好莱坞原则）</li>
<li>1988年，Ralph E. Johnson &amp; Brian Foote 在《Designing Reusable Classes》中提出“Inversion<br>
of control”（控制反转）</li>
<li>1996年，Michael Mattsson 在《Object-Oriented Frameworks, A survey of methodological<br>
issues》中将“Inversion of control”命名为 “Hollywood principle”</li>
<li>2004年，Martin Fowler 在《Inversion of Control Containers and the Dependency Injection<br>
pattern》中提出了自己对 IoC 以及 DI 的理解</li>
<li>2005年，Martin Fowler 在 《InversionOfControl》对 IoC 做出进一步的说明</li>
</ul>
<h1 id="ioc-主要实现策略">IoC 主要实现策略</h1>
<h2 id="维基百科">维基百科</h2>
<ul>
<li>Using a service locator pattern</li>
<li>Using dependency injection, for example
<ul>
<li>Constructor injection</li>
<li>Parameter injection</li>
<li>Setter injection</li>
<li>Interface injection</li>
</ul>
</li>
<li>Using a contextualized lookup</li>
<li>Using template method design pattern</li>
<li>Using strategy design pattern</li>
</ul>
<h2 id="expert-one-on-onetm-j2eetm-development-without-ejbtm">《Expert One-on-One™ J2EE™ Development without EJB™》</h2>
<h3 id="dependency-lookup">Dependency Lookup</h3>
<blockquote>
<p>The container provides callbacks to components, and a lookup context. This is<br>
the EJB and Apache Avalon approach. It leaves the onus on each component to use container APIs to<br>
look up resources and collaborators. The Inversion of Control is limited to the container invoking<br>
callback methods that application code can use to obtain resources.</p>
</blockquote>
<h3 id="dependency-injection">Dependency Injection</h3>
<blockquote>
<p>Components do no look up; they provide plain Java methods enabling the<br>
container to resolve dependencies. The container is wholly responsible for wiring up components,<br>
passing resolved objects in to JavaBean properties or constructors. Use of JavaBean properties is<br>
called Setter Injection; use of constructor arguments is called Constructor Injection.</p>
</blockquote>
<h1 id="ioc-容器的职责">IoC 容器的职责</h1>
<ul>
<li>依赖处理
<ul>
<li>依赖查找</li>
<li>依赖注入</li>
</ul>
</li>
<li>生命周期管理
<ul>
<li>容器</li>
<li>托管的资源（Java Beans 或其他资源）</li>
</ul>
</li>
<li>配置
<ul>
<li>容器</li>
<li>外部化配置</li>
<li>托管的资源（Java Beans 或其他资源）</li>
</ul>
</li>
</ul>
<h1 id="传统-ioc-容器实现">传统 IoC 容器实现</h1>
<ul>
<li>Java SE
<ul>
<li>Java Beans</li>
<li>Java ServiceLoader SPI</li>
<li>JNDI（Java Naming and Directory Interface）</li>
</ul>
</li>
<li>Java EE
<ul>
<li>EJB（Enterprise Java Beans）</li>
<li>Servlet</li>
</ul>
</li>
<li>开源
<ul>
<li>Apache Avalon（http://avalon.apache.org/closed.html）</li>
<li>PicoContainer（http://picocontainer.com/）</li>
<li>Google Guice（https://github.com/google/guice）</li>
<li>Spring Framework（https://spring.io/projects/spring-framework）</li>
</ul>
</li>
</ul>
<h2 id="java-beans-作为-ioc-容器">Java Beans 作为 IoC 容器</h2>
<ul>
<li>特性
<ul>
<li>依赖查找</li>
<li>生命周期管理</li>
<li>配置元信息</li>
<li>事件</li>
<li>自定义</li>
<li>资源管理</li>
<li>持久化</li>
</ul>
</li>
<li>规范
<ul>
<li>JavaBeans：https://www.oracle.com/technetwork/java/javase/tech/index-jsp-138795.html</li>
<li>BeanContext：https://docs.oracle.com/javase/8/docs/technotes/guides/beans/spec/beancontext.html</li>
</ul>
</li>
</ul>
<h1 id="轻量级-ioc-容器">轻量级 IoC 容器</h1>
<ul>
<li>《Expert One-on-One™ J2EE™ Development without EJB™》认为轻量级容器的特征：
<ul>
<li>A container that can manage application code.</li>
<li>A container that is quick to start up.</li>
<li>A container that doesn't require any special deployment steps to deploy objects within it.</li>
<li>A container that has such a light footprint and minimal API dependencies that it can be run in a variety of environments.</li>
<li>A container that sets the bar for adding a managed object so low in terms of deployment effort and performance<br>
overhead that it's possible to deploy and manage fine-grained objects, as well as coarse-grained components.</li>
</ul>
</li>
<li>《Expert One-on-One™ J2EE™ Development without EJB™》认为轻量级容器的好处：
<ul>
<li>Escaping the monolithic container</li>
<li>Maximizing code reusability</li>
<li>Greater object orientation</li>
<li>Greater productivity</li>
<li>Better testability</li>
</ul>
</li>
</ul>
<h1 id="构造器注入-vs-setter-注入">构造器注入 VS. Setter 注入</h1>
<p>Spring Framework 对构造器注入与 Setter 的论点：</p>
<blockquote>
<p>“The Spring team generally advocates constructor injection, as it lets you implement application components as<br>
immutable objects and ensures that required dependencies are not null. Furthermore, constructor-injected components<br>
are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor<br>
arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to<br>
better address proper separation of concerns.</p>
</blockquote>
<blockquote>
<p>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values<br>
within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of<br>
setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later.<br>
Management through JMX MBeans is therefore a compelling use case for setter injection.”</p>
</blockquote>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为 Setter 注入的优点：</p>
<ul>
<li>JavaBean properties are well supported in IDEs.</li>
<li>JavaBean properties are self-documenting.</li>
<li>JavaBean properties are inherited by subclasses without the need for any code.</li>
<li>It's possible to use the standard JavaBeans property-editor machinery for type conversions if necessary.</li>
<li>Many existing JavaBeans can be used within a JavaBean-oriented IoC container without modification.</li>
<li>If there is a corresponding getter for each setter (making the property readable, as well as writable), it is possible to ask<br>
the component for its current configuration state. This is particularly useful if we want to persist that state: for example,<br>
in an XML form or in a database. With Constructor Injection, there's no way to find the current state.</li>
<li>Setter Injection works well for objects that have default values, meaning that not all properties need to be supplied at<br>
runtime.</li>
</ul>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为 Setter 注入的缺点：</p>
<blockquote>
<p>The order in which setters are called is not expressed in any contract. Thus, we sometimes need to invoke a<br>
method after the last setter has been called to initialize the component. Spring provides the<br>
org.springframework.beans.factory.InitializingBean interface for this; it also provides the ability to invoke an<br>
arbitrary init method. However, this contract must be documented to ensure correct use outside a container.Not all the necessary setters may have been called before use. The object can thus be left partially configured.</p>
</blockquote>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为构造器注入的优点：</p>
<blockquote>
<p>Each managed object is guaranteed to be in a consistent state—fully configured—before it can be invoked in<br>
any business methods. This is the primary motivation of Constructor Injection. (However, it is possible to achieve<br>
the same result with JavaBeans via dependency checking, as Spring can optionally perform.) There's no need for<br>
initialization methods.</p>
</blockquote>
<blockquote>
<p>There may be slightly less code than results from the use of multiple JavaBean methods, although will be no<br>
difference in complexity.</p>
</blockquote>
<p>《Expert One-on-One™ J2EE™ Development without EJB™》认为构造器注入的缺点：</p>
<ul>
<li>Although also a Java-language feature, multi-argument constructors are probably less common in existing code than<br>
use of JavaBean properties.</li>
<li>Java constructor arguments don't have names visible by introspection.</li>
<li>Constructor argument lists are less well supported by IDEs than JavaBean setter methods.</li>
<li>Long constructor argument lists and large constructor bodies can become unwieldy.</li>
<li>Concrete inheritance can become problematic.</li>
<li>Poor support for optional properties, compared to JavaBeans</li>
<li>Unit testing can be slightly more difficult</li>
<li>When collaborators are passed in on object construction, it becomes impossible to change the reference held in the<br>
object.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习(三)]]></title>
        <id>https://k-21d.github.io/post/jvm-xue-xi-san/</id>
        <link href="https://k-21d.github.io/post/jvm-xue-xi-san/">
        </link>
        <updated>2019-03-30T11:19:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jvm参数">JVM参数</h2>
<h3 id="标准参数">标准参数</h3>
<pre><code>-version
-help
-server
-cp
</code></pre>
<h3 id="-x参数">-X参数</h3>
<blockquote>
<p>非标准参数，也就是在JDK各个版本中可能会变动</p>
</blockquote>
<pre><code>-Xint 解释执行
-Xcomp 第一次使用就编译成本地代码
-Xmixed 混合模式，JVM自己来决定
</code></pre>
<h3 id="-xx参数">-XX参数</h3>
<blockquote>
<p>非标准化参数，相对不稳定，主要用于JVM调优和Debug</p>
</blockquote>
<pre><code>a.Boolean类型
格式：-XX:[+-]&lt;name&gt; +或-表示启用或者禁用name属性
比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器
-XX:+UseG1GC 表示启用G1类型的垃圾回收器
b.非Boolean类型
格式：-XX&lt;name&gt;=&lt;value&gt;表示name属性的值是value
比如：-XX:MaxGCPauseMillis=500
</code></pre>
<h3 id="其他参数">其他参数</h3>
<pre><code>-Xms1000等价于-XX:InitialHeapSize=1000
-Xmx1000等价于-XX:MaxHeapSize=1000
-Xss100等价于-XX:ThreadStackSize=100
</code></pre>
<h3 id="查看参数">查看参数</h3>
<pre><code>java -XX:+PrintFlagsFinal -version &gt; flags.txt
</code></pre>
<p>导出当前JVM所有参数</p>
<pre><code>[Global flags]
ccstrlist AOTLibrary                               =        {product} {default}
    uintx AdaptiveSizeDecrementScaleFactor         = 4      {product} {default}
    uintx AdaptiveSizeMajorGCDecayTimeScale        = 10     {product} {default}
    uintx AdaptiveSizePolicyCollectionCostMargin   = 50     {product} {default}
    uintx AdaptiveSizePolicyInitializingSteps      = 20     {product} {default}
    uintx AdaptiveSizePolicyOutputInterval         = 0      {product} {default}
	......
</code></pre>
<h2 id="常用命令">常用命令</h2>
<h3 id="jps">jps</h3>
<blockquote>
<p>查看java进程</p>
</blockquote>
<h3 id="jinfo">jinfo</h3>
<ol>
<li>
<p>实时查看和调整JVM配置参数</p>
</li>
<li>
<p>查看</p>
<blockquote>
<p>jinfo -flag name PID 查看某个java进程的name属性的值</p>
</blockquote>
</li>
<li>
<p>修改</p>
<blockquote>
<p>参数只有被标记为manageable的flags可以被实时修改</p>
<p>jinfo -flag [+|-] PID<br>
jinfo -flag = PID</p>
</blockquote>
</li>
<li>
<p>查看曾经赋过值的一些参数</p>
<blockquote>
<p>jinfo -flags PID</p>
</blockquote>
</li>
</ol>
<h3 id="jstat">jstat</h3>
<ol>
<li>
<p>查看虚拟机性能统计信息</p>
</li>
<li>
<p>查看类装载信息</p>
<blockquote>
<p>jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次</p>
</blockquote>
<pre><code>Loaded  Bytes  Unloaded  Bytes     Time
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
  6382 11595.6        0     0.0       8.34
</code></pre>
</li>
<li>
<p>查看垃圾收集信息</p>
<blockquote>
<p>jstat -gc PID 1000 10</p>
</blockquote>
<pre><code> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
22528.0 23040.0  0.0    0.0   125440.0  8855.3   221184.0    9798.0   43008.0 34261.3 9728.0 4370.4      6    0.107   3      0.255    0.362
</code></pre>
</li>
</ol>
<h3 id="jstack">jstack</h3>
<ol>
<li>
<p>查看线程堆栈信息</p>
</li>
<li>
<p>用法</p>
<blockquote>
<p>jstack PID</p>
</blockquote>
</li>
</ol>
<h3 id="jmap">jmap</h3>
<ol>
<li>
<p>生成堆转储快照</p>
</li>
<li>
<p>打印出堆内存相关信息</p>
<blockquote>
<p>-XX:+PrintFlagsFinal -Xms300M -Xmx300M<br>
jmap -heap PID</p>
</blockquote>
</li>
<li>
<p>dump出堆内存相关信息</p>
<blockquote>
<p>jmap -dump:format=b,file=heap.hprof PID</p>
</blockquote>
</li>
<li>
<p>在发生堆内存溢出的时候，自动dump文件</p>
<blockquote>
<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</p>
</blockquote>
</li>
</ol>
<h2 id="常用工具">常用工具</h2>
<h3 id="jconsole">jconsole</h3>
<p>JConsole工具是JDK自带的可视化监控工具。查看java应用程序的运行概况、监控堆信息、永久区使用情况、类加载情况等。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2020/png/713413/1586535385947-f5880d06-97dc-4d5c-99dd-86f1b8ec5aa1.png" alt="jconsole" loading="lazy"></figure>
<h3 id="jvisualvm">jvisualvm</h3>
<figure data-type="image" tabindex="2"><img src="https://cdn.nlark.com/yuque/0/2020/png/713413/1586535392851-31a001bc-f758-4560-a835-0f14eda06072.png" alt="jvisualvm" loading="lazy"></figure>
<h3 id="arthas">Arthas</h3>
<p>github ：https://github.com/alibaba/arthas</p>
<p>启动arthas</p>
<pre><code>curl -O https://alibaba.github.io/arthas/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre>
<h4 id="常用命令-2">常用命令</h4>
<pre><code>version:查看arthas版本号
help:查看命名帮助信息
cls:清空屏幕
session:查看当前会话信息
quit:退出arthas客户端
---
dashboard:当前进程的实时数据面板
thread:当前JVM的线程堆栈信息
jvm:查看当前JVM的信息
sysprop:查看JVM的系统属性
---
sc:查看JVM已经加载的类信息
dump:dump已经加载类的byte code到特定目录
jad:反编译指定已加载类的源码
---
monitor:方法执行监控
watch:方法执行数据观测
trace:方法内部调用路径，并输出方法路径上的每个节点上耗时
stack:输出当前方法被调用的调用路径
......
</code></pre>
<h3 id="mat">MAT</h3>
<blockquote>
<p>Java堆分析器，用于查找内存泄漏</p>
<p>Heap Dump，称为堆转储文件，是Java进程在某个时间内的快照</p>
<p>下载地址 ：https://www.eclipse.org/mat/downloads.php</p>
</blockquote>
<h4 id="dump信息包含的内容">Dump信息包含的内容</h4>
<ul>
<li>
<p>All Objects</p>
<blockquote>
<p>Class, fields, primitive values and references</p>
</blockquote>
</li>
<li>
<p>All Classes</p>
<blockquote>
<p>Classloader, name, super class, static fields</p>
</blockquote>
</li>
<li>
<p>Garbage Collection Roots</p>
<blockquote>
<p>Objects defined to be reachable by the JVM</p>
</blockquote>
</li>
<li>
<p>Thread Stacks and Local Variables</p>
<blockquote>
<p>The call-stacks of threads at the moment of the snapshot, and per-frame information about local<br>
objects</p>
</blockquote>
</li>
</ul>
<h4 id="获取dump文件">获取Dump文件</h4>
<ol>
<li>
<p>手动</p>
<pre><code>jmap -dump:format=b,file=heap.hprof PID
</code></pre>
</li>
<li>
<p>自动</p>
</li>
</ol>
<pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof
</code></pre>
<h4 id="使用">使用</h4>
<ul>
<li>
<p>Histogram</p>
<blockquote>
<p>Histogram可以列出内存中的对象，对象的个数及其大小</p>
</blockquote>
</li>
<li>
<p>Leak Suspects</p>
<blockquote>
<p>查找并分析内存泄漏的可能原因</p>
</blockquote>
</li>
<li>
<p>Top Consumers</p>
<blockquote>
<p>列出大对象</p>
</blockquote>
</li>
</ul>
<h3 id="gc日志分析工具">GC日志分析工具</h3>
<p>获取GC日志文件</p>
<pre><code>-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:gc.log
</code></pre>
<ul>
<li>GCViewer</li>
<li>http://gceasy.io</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习(二)]]></title>
        <id>https://k-21d.github.io/post/jvm-xue-xi-er/</id>
        <link href="https://k-21d.github.io/post/jvm-xue-xi-er/">
        </link>
        <updated>2019-03-16T10:03:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jvm内存模型">JVM内存模型</h1>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2020/png/713413/1586365121505-33596669-d3c5-4dd0-8843-c195db16124f.png" alt="JVM" loading="lazy"></figure>
<blockquote>
<p>JVM内存区域分为非堆区和堆区，堆区分为两大块，一个是一个是Old区，一个是Young区。</p>
<p>Young区分为两大块，一个是Survivor区（S0+S1），一块是Eden区。 Eden:S0:S1=8:1:1</p>
<p>S0和S1一样大，也可以叫From和To。</p>
</blockquote>
<h2 id="对象创建所在区域">对象创建所在区域</h2>
<p>一般情况下，新创建的对象都会被分配到Eden区，一些特殊的大的对象会直接分配到Old区。</p>
<p>比如有对象A，B，C等创建在Eden区，但是Eden区的内存空间肯定有限，比如有100M，假如已经使用了100M或者达到一个设定的临界值，这时候就需要对Eden内存空间进行清理，即垃圾收集(Garbage Collect)，这样的GC我们称之为Minor GC，Minor GC指得是Young区的GC。</p>
<p>经过GC之后，有些对象就会被清理掉，有些对象可能还存活着，对于存活着的对象需要将其复制到Survivor区，然后再清空Eden区中的这些对象。</p>
<h2 id="survivor区">Survivor区</h2>
<p>Survivor区分为两块S0和S1，也可以叫做Survivor From和Survivor To。</p>
<p>在同一个时间点上，S0和S1只能有一个区有数据，另外一个是空的。</p>
<p>如果一开始只有Eden区和From中有对象，To中是空的。 此时进行一次GC操作，From区中对象的年龄就会+1，  Eden区中所有存活的对象会被复制到To区，From区中还能存活的对象会有两个去处。</p>
<ul>
<li>若对象年龄达到之前设置好的年龄阈值，此时对象会被移动到Old区</li>
<li>如果Eden区和From区没有达到阈值的对象会被复制到To区</li>
</ul>
<p>此时Eden区和From区已经被清空 。这时候From和To交换角色，之前的From变成了To，之前的To变成了From。也就是说无论如何都要保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到To区被填满，然后会将所有对象复制到老年代中。</p>
<h2 id="old区">Old区</h2>
<p>一般Old区都是年龄比较大的对象，或者相对超过了某个阈值的对象。</p>
<p>在Old区也会有GC的操作，Old区的GC我们称作为Major GC。</p>
<h2 id="总结">总结</h2>
<figure data-type="image" tabindex="2"><img src="https://cdn.nlark.com/yuque/0/2020/png/713413/1586365139828-77823d12-dced-40b3-87ed-21ba85fbe8e1.png" alt="JVM_MEMORY" loading="lazy"></figure>
<h3 id="如何理解minormajorfull-gc">如何理解Minor/Major/Full GC</h3>
<ul>
<li>Minor GC:新生代</li>
<li>Major GC:老年代</li>
<li>Full GC:新生代+老年代</li>
</ul>
<h3 id="为什么需要survivor区只有eden不行吗">为什么需要Survivor区?只有Eden不行吗？</h3>
<p>如果没有Survivor,Eden区每进行一次Minor GC,并且没有年龄限制的话，存活的对象就会被送到老年代。这样一来，老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。老年代的内存空间远大于新生代,进行一次Full GC消耗的时间比Minor GC长得多。</p>
<p>假如增加老年代空间，更多存活对象才能填满老年代。虽然降低Full GC频率，但是随着老年代空间加大,一旦发生Full  GC,执行所需要的时间更长。</p>
<p>假如减少老年代空间，虽然Full GC所需时间减少，但是老年代很快被存活对象填满,Full GC频率增加。</p>
<p>所以Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16 次Minor GC还能在新生代中存活的对象,才会被送到老年代。</p>
<h3 id="为什么需要两个survivor区">为什么需要两个Survivor区？</h3>
<p>最大的好处就是解决了碎片化，永远有一个Survivor space是空的,另一个非空的Survivor space无碎片。</p>
<h3 id="新生代中edens1s2为什么是811">新生代中Eden:S1:S2为什么是8:1:1？</h3>
<p>新生代中的可用内存：复制算法用来担保的内存为9：1</p>
<p>可用内存中Eden：S1区为8：1</p>
<p>即新生代中Eden:S1:S2 = 8：1：1</p>
<h2 id="使用java-visualvm查看">使用Java VisualVM查看</h2>
<p>安装Visual GC插件可查看内存区域</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.nlark.com/yuque/0/2020/png/713413/1586365163981-396f6eef-f866-44b6-b2e3-0a4d64d499fe.png" alt="" loading="lazy"></figure>
<h3 id="堆内存溢出">堆内存溢出</h3>
<figure data-type="image" tabindex="4"><img src="https://cdn.nlark.com/yuque/0/2020/gif/713413/1586365180853-b0544d77-9e30-44e3-b1d1-7a65194731e7.gif" alt="GIF 2020-4-8 13-56-33" loading="lazy"></figure>
<h3 id="方法区内存溢出">方法区内存溢出</h3>
<pre><code>java.lang.OutOfMemoryError: Metaspace
	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_211]
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_211]
	at java.lang.ClassLoader.defineClass(ClassLoader.java:642) ~[na:1.8.0_211]
</code></pre>
<h3 id="虚拟机栈">虚拟机栈</h3>
<pre><code>public class StackOverFlowDemo {

    public static long count=0;

    public static void method(long i){
        System.out.println(count++);
        method(i);
    }

    public static void main(String[] args) {
        method(1);
    }
}
</code></pre>
<p>设置JVM参数<code>-Xss128k</code>运行结果：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.StackOverflowError
	at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:77)
	at sun.nio.cs.UTF_8.access$200(UTF_8.java:57)
	at sun.nio.cs.UTF_8$Encoder.encodeArrayLoop(UTF_8.java:636)
	at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:691)
	......
</code></pre>
<blockquote>
<p>Stack Space用来做方法的递归调用时压入Stack Frame(栈帧)。所以当递归调用太深的时候，就有可能耗尽Stack Space，爆出StackOverflow的错误。</p>
<p>-Xss128k：设置每个线程的堆栈大小。JDK 5以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。</p>
<p>线程栈的大小如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。</p>
</blockquote>
<h1 id="garbage-collect垃圾回收">Garbage Collect(垃圾回收)</h1>
<h2 id="如何确定一个对象是垃圾">如何确定一个对象是垃圾？</h2>
<p>要想进行垃圾回收，得先知道什么样的对象是垃圾。</p>
<h3 id="引用计数法">引用计数法</h3>
<p>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任<br>
何指针对其引用，它就是垃圾。</p>
<p><strong>弊端 :</strong> 如果AB相互持有引用，导致永远不能被回收。</p>
<h3 id="可达性分析">可达性分析</h3>
<p>通过GC Root的对象，开始向下寻找，看某个对象是否可达</p>
<blockquote>
<p>能作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法<br>
栈的变量等。</p>
</blockquote>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<h3 id="标记-清除mark-sweep">标记-清除(Mark-Sweep)</h3>
<ul>
<li>
<p>标记：找出内存中需要回收的对象，并且把它们标记出来</p>
<blockquote>
<p>此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时</p>
</blockquote>
</li>
<li>
<p>清除：清除掉被标记需要回收的对象，释放出对应的内存空间</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>标记和清除两个过程都比较耗时，效率不高</li>
<li>会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无<br>
法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
<h3 id="复制copying">复制(Copying)</h3>
<p>将内存划分为两块相等的区域，每次只使用其中一块，当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉。</p>
<p><strong>缺点:</strong> 空间利用率降低。</p>
<h3 id="标记-整理mark-compact">标记-整理(Mark-Compact)</h3>
<p>标记过程仍然与&quot;标记-清除&quot;算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h2 id="分代收集算法">分代收集算法</h2>
<ul>
<li>Young区：复制算法(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)</li>
<li>Old区：标记清除或标记整理(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)</li>
</ul>
<h2 id="垃圾收集器">垃圾收集器</h2>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial</td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td>ParNew</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td>CMS</td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td>G1</td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，替换CMS</td>
</tr>
</tbody>
</table>
<h3 id="serial收集器">Serial收集器</h3>
<p>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯<br>
一选择。<br>
它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更<br>
重要的是其在进行垃圾收集的时候需要暂停其他线程。</p>
<blockquote>
<p>优点：简单高效，拥有很高的单线程收集效率<br>
缺点：收集过程需要暂停所有线程<br>
算法：复制算法<br>
适用范围：新生代<br>
应用：Client模式下的默认新生代收集器</p>
</blockquote>
<h3 id="parnew收集器">ParNew收集器</h3>
<p>可以把这个收集器理解为Serial收集器的多线程版本。</p>
<blockquote>
<p>优点：在多CPU时，比Serial效率高。<br>
缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。<br>
算法：复制算法<br>
适用范围：新生代<br>
应用：运行在Server模式下的虚拟机中首选的新生代收集器</p>
</blockquote>
<h3 id="parallel-scavenge收集器">Parallel Scavenge收集器</h3>
<p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集<br>
器，看上去和ParNew一样，但是Parallel Scanvenge更关注 系统的吞吐量 。</p>
<blockquote>
<p>吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)<br>
比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。<br>
若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序<br>
的运算任务。</p>
</blockquote>
<h3 id="serial-old收集器">Serial Old收集器</h3>
<p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用&quot;标记-整理算<br>
法&quot;，运行过程和Serial收集器一样。</p>
<h3 id="parallel-old收集器">Parallel Old收集器</h3>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和&quot;标记-整理算法&quot;进行垃圾<br>
回收。</p>
<h3 id="cms收集器">CMS收集器</h3>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>采用的是&quot;标记-清除算法&quot;,整个过程分为4步</p>
<ul>
<li>初始标记 CMS initial mark 	         (标记GC Roots能关联到的对象 Stop The World---&gt;速度很快）</li>
<li>并发标记 CMS concurrent mark （进行GC Roots Tracing）</li>
<li>重新标记 CMS remark                  （修改并发标记因用户程序变动的内容 Stop The World）</li>
<li>并发清除 CMS concurrent sweep</li>
</ul>
<p>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。</p>
<blockquote>
<p>优点：并发收集、低停顿<br>
缺点：产生大量空间碎片、并发阶段会降低吞吐量</p>
</blockquote>
<h3 id="g1收集器">G1收集器</h3>
<p>G1特点</p>
<ul>
<li>并行与并发</li>
<li>分代收集（仍然保留了分代的概念）</li>
<li>空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）</li>
<li>可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</li>
</ul>
<p>使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>工作过程可以分为如下几步 ：</p>
<ul>
<li>初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂停用户线程</li>
<li>并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发执行</li>
<li>最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需暂停用户线程</li>
<li>筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划</li>
</ul>
<p>判断是否需要使用G1收集器？</p>
<ul>
<li>50%以上的堆被存活对象占用</li>
<li>对象分配和晋升的速度变化非常大</li>
<li>垃圾回收时间比较长</li>
</ul>
<h3 id="垃圾收集器分类">垃圾收集器分类</h3>
<ul>
<li>
<p>串行收集器-&gt;Serial和Serial Old</p>
<blockquote>
<p>只能有一个垃圾回收线程执行，用户线程暂停。 适用于内存比较小的嵌入式设备 。</p>
</blockquote>
</li>
<li>
<p>并行收集器[吞吐量优先]-&gt;Parallel Scanvenge、Parallel Old</p>
<blockquote>
<p>多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 适用于科学计算、后台处理等若交互场景 。</p>
</blockquote>
</li>
<li>
<p>并发收集器[停顿时间优先]-&gt;CMS、G1</p>
<blockquote>
<p>用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。 适用于相对时间有要求的场景，比如Web 。</p>
</blockquote>
</li>
</ul>
<h3 id="吞吐量和停顿时间">吞吐量和停顿时间</h3>
<ul>
<li>停顿时间：垃圾收集器进行垃圾回收终端应用执行响应的时间</li>
<li>吞吐量：运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>
</ul>
<h3 id="如何选择合适的垃圾收集器">如何选择合适的垃圾收集器</h3>
<ul>
<li>优先调整堆的大小让服务器自己来选择</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核，并且没有停顿时间要求，使用串行或JVM自己选</li>
<li>如果允许停顿时间超过1秒，选择并行或JVM自己选</li>
<li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li>
<li>对于G1收集</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM学习(一)]]></title>
        <id>https://k-21d.github.io/post/jvm-xue-xi-yi/</id>
        <link href="https://k-21d.github.io/post/jvm-xue-xi-yi/">
        </link>
        <updated>2019-03-08T15:21:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="description-of-java-conceptual-diagram"><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/desc_jdk_structure.html">Description of Java Conceptual Diagram</a></h2>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2020/png/713413/1586276237017-68820129-1062-495a-975f-a70a8461ecae.png" alt="1586239432416" loading="lazy"></figure>
<h2 id="源码到类文件">源码到类文件</h2>
<h3 id="源码">源码</h3>
<p>Person.java</p>
<pre><code>class Person{
    private String name;
    private int age;
    private static String address;
    private final static String hobby=&quot;Programming&quot;;
    public void say(){
        System.out.println(&quot;person say...&quot;);
    } 
    public int calc(int op1,int op2){
      return op1+op2;
    }
}
</code></pre>
<blockquote>
<p>编译: javac Person.java ---&gt; Person.class</p>
</blockquote>
<h3 id="编译过程">编译过程</h3>
<blockquote>
<p>Person.java -&gt; 词法分析器 -&gt; tokens流 -&gt; 语法分析器 -&gt; 语法树/抽象语法树 -&gt; 语义分析器<br>
-&gt; 注解抽象语法树 -&gt; 字节码生成器 -&gt; Person.class文件</p>
</blockquote>
<h3 id="类文件">类文件</h3>
<p>将Person.class以16进制查看</p>
<pre><code>cafe babe 0000 0034 0027 0a00 0600 1809
0019 001a 0800 1b0a 001c 001d 0700 1e07
001f 0100 046e 616d 6501 0012 4c6a 6176
612f 6c61 6e67 2f53 7472 696e 673b 0100
0361 6765 0100 0149 0100 0761 6464 7265
7373 0100 0568 6f62 6279 0100 0d43 6f6e
7374 616e 7456 616c 7565 0800 2001 0006
3c69 6e69 743e 0100 0328 2956 0100 0443
6f64 6501 000f 4c69 6e65 4e75 6d62 6572
5461 626c 6501 0003 7361 7901 0004 6361
6c63 0100 0528 4949 2949 0100 0a53 6f75
7263 6546 696c 6501 000b 5065 7273 6f6e
2e6a 6176 610c 000f 0010 0700 210c 0022
0023 0100 0d70 6572 736f 6e20 7361 792e
2e2e 0700 240c 0025 0026 0100 0650 6572
736f 6e01 0010 6a61 7661 2f6c 616e 672f
4f62 6a65 6374 0100 0b50 726f 6772 616d
6d69 6e67 0100 106a 6176 612f 6c61 6e67
2f53 7973 7465 6d01 0003 6f75 7401 0015
4c6a 6176 612f 696f 2f50 7269 6e74 5374
7265 616d 3b01 0013 6a61 7661 2f69 6f2f
5072 696e 7453 7472 6561 6d01 0007 7072
696e 746c 6e01 0015 284c 6a61 7661 2f6c
616e 672f 5374 7269 6e67 3b29 5600 2000
0500 0600 0000 0400 0200 0700 0800 0000
0200 0900 0a00 0000 0a00 0b00 0800 0000
1a00 0c00 0800 0100 0d00 0000 0200 0e00
0300 0000 0f00 1000 0100 1100 0000 1d00
0100 0100 0000 052a b700 01b1 0000 0001
0012 0000 0006 0001 0000 0001 0001 0013
0010 0001 0011 0000 0025 0002 0001 0000
0009 b200 0212 03b6 0004 b100 0000 0100
1200 0000 0a00 0200 0000 0700 0800 0800
0100 1400 1500 0100 1100 0000 1c00 0200
0300 0000 041b 1c60 ac00 0000 0100 1200
0000 0600 0100 0000 0a00 0100 1600 0000
0200 17
</code></pre>
<ul>
<li>magic</li>
</ul>
<blockquote>
<p>The magic item supplies the magic number identifying the class file format; it has the<br>
value 0xCAFEBABE .</p>
</blockquote>
<ul>
<li>minor_version, major_version</li>
</ul>
<blockquote>
<p>0000 0034 对应10进制的52，代表JDK 8中的一个版本</p>
</blockquote>
<ul>
<li>constant_pool_count</li>
</ul>
<blockquote>
<p>0027 对应十进制27，代表常量池中27个常量</p>
</blockquote>
<pre><code>//A class file consists of a single ClassFile structure:
ClassFile {
    u4 magic;
    u2 minor_version;
    u2 major_version; 
    u2 constant_pool_count;
    cp_info constant_pool[constant_pool_count-1];//常量池中常量
    u2 access_flags;//访问标志
    u2 this_class;//类索引
    u2 super_class;//父类索引
    u2 interfaces_count;//接口索引
    u2 interfaces[interfaces_count];
    u2 fields_count;
    field_info fields[fields_count]; //字段表集合
    u2 methods_count;
    method_info methods[methods_count];//方法表集合
    u2 attributes_count;
    attribute_info attributes[attributes_count];//属性表集合
}
</code></pre>
<h2 id="类加载机制">类加载机制</h2>
<h3 id="装载load">装载(Load)</h3>
<p>查找和导入class文件</p>
<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口</li>
</ol>
<h3 id="链接link">链接(Link)</h3>
<h4 id="验证verify">验证(Verify)</h4>
<p>保证被加载类的正确性</p>
<ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>
<h4 id="准备prepare">准备(Prepare)</h4>
<p>为类的静态变量分配内存，并将其初始化为默认值</p>
<h4 id="解析resolve">解析(Resolve)</h4>
<p>把类中的符号引用转换为直接引用</p>
<h3 id="初始化initialize">初始化(Initialize)</h3>
<p>对类的静态变量，静态代码块执行初始化操作</p>
<h2 id="类装载器classloader">类装载器ClassLoader</h2>
<p>在装载(Load)阶段，其中第(1)步:通过类的全限定名获取其定义的二进制字节流，需要借助类装载<br>
器完成，顾名思义，就是用来装载Class文件的。</p>
<h3 id="分类">分类</h3>
<table>
<thead>
<tr>
<th>Bootstrap ClassLoader</th>
<th>负责加载$JAVA_HOME中 jre/lib/rt.jar 里所有的class或Xbootclassoath选项指定的jar包。由C++实现，不是ClassLoader子类。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Extension ClassLoader</td>
<td>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar 或 -Djava.ext.dirs指定目录下的jar包</td>
</tr>
<tr>
<td>App ClassLoader</td>
<td>负责加载classpath中指定的jar包及 Djava.class.path 所指定目录下的类和jar包</td>
</tr>
<tr>
<td>Custom ClassLoader</td>
<td>通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</td>
</tr>
</tbody>
</table>
<h3 id="加载原则">加载原则</h3>
<p>检查某个类是否已经加载：顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检<br>
查，只要某个Classloader已加载，就视为已加载此类，保证此类只所有ClassLoader加载一次。</p>
<p>加载的顺序：加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
<h4 id="双亲委派机制">双亲委派机制</h4>
<ul>
<li>
<p>定义</p>
<blockquote>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把<br>
这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就<br>
成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p>
</blockquote>
</li>
<li>
<p>优势</p>
<blockquote>
<p>Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。比如，Java中的<br>
Object类，它存放在rt.jar之中,无论哪一个类加载器要加载这个类，最终都是委派给处于模型<br>
最顶端的启动类加载器进行加载，因此Object在各种类加载环境中都是同一个类。如果不采用<br>
双亲委派模型，那么由各个类加载器自己取加载的话，那么系统中会存在多种不同的Object<br>
类。</p>
</blockquote>
</li>
<li>
<p>破坏</p>
<blockquote>
<p>可以继承ClassLoader类，然后重写其中的loadClass方法</p>
</blockquote>
</li>
</ul>
<h2 id="运行时数据区run-time-data-areas">运行时数据区(Run-Time Data Areas)</h2>
<h3 id="method-area方法区">Method Area(方法区)</h3>
<p>方法区是各个线程共享的内存区域，在虚拟机启动时创建。</p>
<p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap(非堆)，目<br>
的是与Java堆区分开来。</p>
<p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<blockquote>
<p>The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads.<br>
The method area is created on virtual machine start-up. Although the method area is logically part of the heap,......<br>
If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an OutOfMemoryError.</p>
</blockquote>
<ul>
<li>方法区在JDK 8中就是Metaspace，在JDK6或7中就是Perm Space</li>
<li>Run-Time Constant Pool</li>
</ul>
<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<h3 id="heap堆">Heap(堆)</h3>
<p>Java堆是Java虚拟机所管理内存中最大的一块，在虚拟机启动时创建，被所有线程共享。<br>
Java对象实例以及数组都在堆上分配。</p>
<blockquote>
<p>The Java Virtual Machine has a heap that is shared among all Java Virtual Machine threads. The heap is the run-time data area from which memory for all class instances and arrays is allocated. The heap is created on virtual machine start-up.</p>
</blockquote>
<h3 id="java-virtual-machine-stacks虚拟机栈">Java Virtual Machine Stacks(虚拟机栈)</h3>
<p>虚拟机栈是一个线程执行的区域，保存着一个线程中方法的调用状态。换句话说，一个Java线程的运行状态，由一个虚拟机栈来保存，所以虚拟机栈肯定是线程私有的，独有的，随着线程的创建而创建。</p>
<p>每一个被线程执行的方法，为该栈中的栈帧，即每个方法对应一个栈帧。</p>
<p>调用一个方法，就会向栈中压入一个栈帧；一个方法调用完成，就会把该栈帧从栈中弹出。</p>
<blockquote>
<p>Each Java Virtual Machine thread has a private Java Virtual Machine stack,<br>
created at the same time as the thread. A Java Virtual Machine stack stores<br>
frames (§2.6).</p>
</blockquote>
<p>Person类的字节码文件反编译结果：</p>
<pre><code>Compiled from &quot;Person.java&quot;
class Person {
  Person();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: return

  public void say();
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #3                  // String person say...
       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return

  public int calc(int, int);
    Code:
       0: iload_1
       1: iload_2
       2: iadd
       3: ireturn
}

</code></pre>
<h4 id="栈帧">栈帧</h4>
<p>栈帧：每个栈帧对应一个被调用的方法，可以理解为一个方法的运行空间。</p>
<ul>
<li>
<p>局部变量表(Local Variables)</p>
<blockquote>
<p>方法中定义的局部变量以及方法的参数存放在这张表中。局部变量表中的变量不可直接使用，如需要使用的话，必须通过相关指令将其加载至操作数栈中作为操作数使用。</p>
</blockquote>
</li>
<li>
<p>操作数栈(Operand Stack)</p>
<blockquote>
<p>以压栈和出栈的方式存储操作数的</p>
</blockquote>
</li>
<li>
<p>动态链接  (Dynamic Linking)</p>
<blockquote>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接(Dynamic Linking)。</p>
</blockquote>
</li>
<li>
<p>方法返回地址(Return Address)</p>
<blockquote>
<p>当一个方法开始执行后,只有两种方式可以退出，一种是遇到方法返回的字节码指令；一种是遇见异常，并且这个异常没有在方法体内得到处理。</p>
</blockquote>
</li>
<li>
<p>附加信息</p>
</li>
</ul>
<h3 id="the-pc-register程序计数器">The pc Register(程序计数器)</h3>
<p>程序计数器占用的内存空间很小，由于Java虚拟机的多线程是通过线程轮流切换，并分配处理器执行时间的方式来实现的，在任意时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程需要有一个独立的程序计数器(线程私有)。</p>
<p>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则这个计数器为空。</p>
<blockquote>
<p>The Java Virtual Machine can support many threads of execution at once (JLS§17). Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the current method (§2.6) for that thread. If that method is not native, the pc register contains the address of the Java Virtual Machine instruction currently being executed. If the method currently being executed by the thread is native, the value of the Java Virtual Machine's pc register is undefined. The Java Virtual Machine's pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.</p>
</blockquote>
<h3 id="native-method-stacks本地方法栈">Native Method Stacks(本地方法栈)</h3>
<p>如果当前线程执行的方法是Native类型的，这些方法就会在本地方法栈中执行。</p>
]]></content>
    </entry>
</feed>